#include 'totvs.ch'


#define BASE_DIR 'notas_impressas\'


/*/{Protheus.doc} PdfAttachment
Classe para gerenciar anexo da nota em PDF

@author Rafael Ricardo Vieceli
@since 11/09/2019
@version 1.0

@type class
/*/
class PdfAttachment from LongNameClass

  data file
  data autoGenerated
  data key
  data fromBill

  method dummie(branch, document, series, supplier, unit, type, key, parcel) constructor
  method new(id) constructor

  method start(branch, document, series, supplier, unit, type, key, parcel)
  method exists()

  method file()

  method upload(file)
  method download(directory)
  method open(directory)
  method downloadAndOpen()
  method drop()

  method generate()
  method getColab()

  method mark(markAs)
  method dismark()

  method message(result, success, error)

  method getFileContentEncoded()

endclass


method dummie(branch, document, series, supplier, unit, type, key, parcel) class PdfAttachment

  ::start(branch, document, series, supplier, unit, type, key, parcel)

return


method new(cAlias, id, parcel) class PdfAttachment

  local nf

  default cAlias := 'SF1'
  default id := (cAlias)->( recno() )

  ::fromBill := cAlias == 'SE2'

  if (cAlias)->( recno() ) != id
    (cAlias)->( dbgoto(id) )
  endif

  if cAlias == 'SE2'
    if SE2->E2_TIPO == MVNOTAFIS .and. parcel == nil
      nf := FINBuscaNF(nil, SE2->E2_NUM, SE2->E2_PREFIXO, SE2->E2_FORNECE, SE2->E2_LOJA, "SF1", .T.)
      SF1->( dbGoTo(nf) )
    endif

    if empty(nf)
      //prefix going fist of number
      ::start(;
        SE2->E2_FILIAL, ;
        SE2->E2_PREFIXO, ;
        SE2->E2_NUM, ;
        SE2->E2_FORNECE, ;
        SE2->E2_LOJA, ;
        SE2->E2_TIPO, ;
        '', ; //chave NFe
      parcel)
      return
    endif

  endif

  ::start(;
    SF1->F1_FILIAL, ;
    SF1->F1_DOC, ;
    SF1->F1_SERIE, ;
    SF1->F1_FORNECE, ;
    SF1->F1_LOJA, ;
    SF1->F1_ESPECIE, ;
    SF1->F1_CHVNFE)

  ::fromBill := .F.

return


method start(branch, document, series, supplier, unit, type, key, parcel) class PdfAttachment

  // [09-090101]SPED[00000001-1][000001-01].pdf
  // empresa + filial
  ::file := "["+FWCodEmp()+"-"+branch+"]"
  // especie (SPED)
  ::file += iif(empty(type), '', alltrim(type))
  //documento + serie
  ::file += "["+alltrim(document)+"-"+alltrim(series)+"]"
  // fornecedor + loja
  ::file += "["+alltrim(supplier)+"-"+alltrim(unit)+"]"

  if parcel != nil
    ::file += "[P-"+alltrim(parcel)+"]"
  endif

  // extensão
  ::file += ".PDF"

  ::key := key

  ::autoGenerated := upper(alltrim(type)) $ 'SPED|'

return


method file() class PdfAttachment
return BASE_DIR + ::file


method exists() class PdfAttachment

  if ! existDir(BASE_DIR)
    makeDir(BASE_DIR)
  endif

return file(::file())


method upload(file) class PdfAttachment

  local result

  if empty(file)
    file := cGetFile("*.PDF|*.pdf", "Selecione o Arquivo",,,.F.,GETF_LOCALHARD+GETF_NETWORKDRIVE,.F.,.T.)

    if empty(file) .or. ! file(file)
      return .F.
    endif
  endif

  if ! existDir(BASE_DIR)
    makeDir(BASE_DIR)
  endif

  if file(::file())
    ferase(::file())
    // adicionar log de exclusao
  endif

  result := __copyfile(file, ::file())
  
  If result
    If SF1->(FieldPos("F1_XANEXO")) > 0 .and. !Empty(SF1->F1_DOC)
        Reclock("SF1",.F.)
          SF1->F1_XANEXO:= '1'
        SF1->(msUnlock())  
      Endif

      If SE2->(FieldPos("E2_XANEXO")) > 0 .and. !Empty(SE2->E2_NUM)
        Reclock("SE2",.F.)
          SE2->E2_XANEXO:= '1'          
        SE2->(msUnlock())
        
        /* SMS */  
        // controle de LOG
        if FWCodEmp() =='09'
          //u_LogAnexo(SE2->E2_FILIAL ,SE2->E2_NUM, 'I', 'SE2', SE2->E2_PARCELA)

          // controle do campo novo de controle pdf anexado a duplicata
          Reclock("SF1",.F.)
            SF1->F1_XNESE2:= '1'          
          SF1->(msUnlock())
        Endif      
      Endif
  Endif

  ::message(result, 'Arquivo salvo com sucesso no servidor.', 'Não foi possivel fazer o upload do arquivo para o servidor.')

return result


method download(directory, lShutUp) class PdfAttachment

  Local result
  Local file

  default lShutUp := .F.

  if empty(directory)

    directory := cGetFile("", "Selecione o Diretório",,,.F.,GETF_LOCALHARD+GETF_NETWORKDRIVE+GETF_RETDIRECTORY,.F.,.T.)

    if empty(directory) .or. ! existDir(directory)
      return .F.
    endif

    file := directory + ::file
  else
    //"C:\Users\user01\AppData\Local\Temp\notas_impressas\xxxx.pdf"
    file := directory + ::file()
  endif

  if file(file)
    ferase(file)
  endif

  result := __copyfile(::file(), file)

  if ! lShutUp
    ::message(result, 'Arquivo salvo com sucesso na pasta indicada.', 'Não foi possivel salvar o arquivo na pasta indicada.')
  endif

return result


method open(directory) class PdfAttachment
return ShellExecute("open", directory + ::file() ,"","",1) == 0


method downloadAndOpen() class PdfAttachment

  local directory := GetTempPath()

  if ! existDir(directory + BASE_DIR)
    makeDir(directory + BASE_DIR)
  endif

  ::download(directory, .T.)

  ::open(directory)

return


method drop() class PdfAttachment

  local result := .f.

  if ::exists()

    if 2 == aviso('Exclusão', "Tem certeza que deseja excluir o PDF das nota?", {'Excluir', 'Não'}, 1)
      return .f.
    endif

    result := ferase(::file()) != -1

    if result
      ::dismark()
      If SF1->(FieldPos("F1_XANEXO")) > 0 .and. !Empty(SF1->F1_DOC)
        Reclock("SF1",.F.)
          SF1->F1_XANEXO:= '2'
        SF1->(msUnlock())  
      Endif

      If SE2->(FieldPos("E2_XANEXO")) > 0 .and. !Empty(SE2->E2_NUM)
        Reclock("SE2",.F.)
          SE2->E2_XANEXO:= '2'
        SE2->(msUnlock())  
        //u_LogAnexo(SE2->E2_FILIAL ,SE2->E2_NUM, 'E', 'SE2', SE2->E2_PARCELA)
      Endif      
    endif

    ::message(result, 'Arquivo excluído com sucesso.', 'Não foi possivel excluir o arquivo.' + CRLF + CRLF + "Error: " + cValToChar(FError()))

  endif

return result


method message(result, success, error) class PdfAttachment

  if ! isBlind()
    if result
      aviso("Sucesso", success, { "Fechar"}, 1)
    else
      aviso("Falha", error, { "Fechar"}, 1)
    endif
  endif

return


method generate(aspetta) class PdfAttachment

  local times := 0
  local directory

  if ! ::autoGenerated
    ::message(.F.,,"Este documento não pode ser gerado pois não é SPED.")
    return .F.
  endif

//  if empty(::key)
//    ::message(.F.,,"Este documento não pode ser gerado pois não tem a CHAVE da nota (F1_CHVNFE).")
//    return .F.
//  endif

  if ::exists()
    ::message(.F.,,"Este documento já existe.")
    return .T.
  endif

  if ! ::getColab()
    return .F.
  endif

  FWMsgRun(,{ || u_DanfeGenerica(::file) }, "Gerando", "Gerando PDF")

  ::mark()

  if aspetta
    while times++ <= 15
      directory := directory(::file())

      if len(directory) == 1 .and. directory[1][2] > 0
        return .T.
      endif
      sleep(200)
    enddo
  endif

return .T.


method getColab(refreshNonProcessed) class PdfAttachment

  local nReg
  local emitterTable := If(SF1->F1_TIPO $ "DB","SA1","SA2")

  default refreshNonProcessed := .t.

  if ! empty( ::key )

    SDS->( dbSetOrder(2) )
    SDS->( dbSeek( xFilial('SDS') + ::key ) )

    if SDS->( found() )
      CKO->( dbSetOrder(1) )
      CKO->( dbSeek( alltrim(SDS->DS_ARQUIVO) ) )

      if CKO->( found() )
        return .T.
      endif
    endif

  endif

  //sem não encontrou com a chave, busco pelo numero e serie, tirando zeros as esquerda de ambos
  nReg := MPSysExecScalar(;
    "select R_E_C_N_O_ " + ;
    "from "+retSqlName("SDS")+" " + ;
    "where DS_FILIAL = '" + xFilial("SDS") + "' " + ;
    "and LTRIM(TRIM(DS_DOC)   , 0) = LTRIM(TRIM( '"+ SF1->F1_DOC + "' )     , 0) " + ;
    "and LTRIM(TRIM(DS_SERIE) , 0) = LTRIM(TRIM( '"+ SF1->F1_SERIE + "' )   , 0) " + ;
    "and DS_FORNEC = '"+ SF1->F1_FORNECE + "' " + ;
    "and DS_LOJA   = '"+ SF1->F1_LOJA + "' " + ;
    "and D_E_L_E_T_ = ' '", "R_E_C_N_O_")


  if nReg > 0
    SDS->( dbGoTo( nReg ) )

    CKO->( dbSetOrder(1) )
    CKO->( dbSeek( alltrim(SDS->DS_ARQUIVO) ) )

    if CKO->( found() )
      return .T.
    endif
  endif

  if AliasInDic("ZCK")

    //atualiza a lista de XML não importados
    if refreshNonProcessed
      u_PDFSch51()
    endif

    dbSelectArea(emitterTable)
    (emitterTable)->( dbSetOrder(1) )
    (emitterTable)->( dbSeek( xFilial(emitterTable) + SF1->F1_FORNECE + SF1->F1_LOJA ) )

    //sem não encontrou com a chave, busco pelo numero e serie, tirando zeros as esquerda de ambos
    nReg := MPSysExecScalar(;
      "select R_E_C_N_O_ " + ;
      "from "+retSqlName("ZCK")+" " + ;
      "where ZCK_FILIAL = '" + xFilial("ZCK") + "' " + ;
      "and LTRIM(TRIM(ZCK_DOC)   , 0) = LTRIM(TRIM( '"+ SF1->F1_DOC + "' )     , 0) " + ;
      "and LTRIM(TRIM(ZCK_SERIE) , 0) = LTRIM(TRIM( '"+ SF1->F1_SERIE + "' )   , 0) " + ;
      "and ZCK_CNPJ = '"+ (emitterTable)->&(prefixoCpo(emitterTable)+'_CGC') + "' " + ;
      "and D_E_L_E_T_ = ' '", "R_E_C_N_O_")


    if nReg > 0
      ZCK->( dbGoTo( nReg ) )

      CKO->( dbSetOrder(1) )
      CKO->( dbSeek( alltrim(ZCK->ZCK_ARQUIV) ) )

      if CKO->( found() )
        return .T.
      endif

    endif
  endif

  ::message(.F., , "Não foi encontrado o XML pela Chave NFE (SDS) ou por comparação do número, série e fornecedor (SDS/ZCK-CKO)")

return .F.


method dismark() class PdfAttachment
  ::mark(.F.)
return

method mark(markAs) class PdfAttachment

  default markAs := .T.

  if ::exists()
    if SF1->(fieldPos('F1_FPDF')) > 0 .and. SF1->F1_FPDF != markAs
      reclock('SF1', .F.)
      SF1->F1_FPDF := markAs
      SF1->( msUnlock() )
    endif
  endif

return


method getFileContentEncoded() class PdfAttachment

  Local cContent := ""
  Local buffer := ''
  Local nHandle := fOpen(::file(), 0)

  while fRead(nHandle, @buffer, 1000) > 0
    cContent += buffer
  enddo

  fClose(nHandle)

return Encode64(cContent)


user function pdfattach_dummie()

  local pdf

  RPCSetEnv('99','01')

  pdf := PdfAttachment():dummie('165465','12', '000001', '01', 'SPED', '35190706053214000102550050000494471334686233')


  //pdf:upload('C:\Users\rafae\Desktop\Profile.pdf')
  pdf:generate(.T.)

  pdf:downloadAndOpen()

  RPCClearEnv()

return
