#INCLUDE "TCBROWSE.CH"
//#INCLUDE "TMKA273C.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "TMKDEF.CH"

#DEFINE TEF_CLISITEF				"6"		// Utiliza a DLL CLISITEF no TeleVendas
#DEFINE _FORMATEF					"CC" 	// Formas de pagamento que utilizam opera?o TEF para valida?o


/*
?????????????????????????????????????????????
?																					 ?
?Posicoes do array aParcelas - por PARCELA											 ?
?1  - Data    																	 	 ?
?2  - Valor    																		 ?
?3  - Forma de Pagamento 															 ?
?4  - Observacao            															 ?
?5  - Valor em Percentual 									   					     ?
?6  - ID Cartao (quando usar Multi-TEF)								   			     ?
?																					 ?
?????????????????????????????????????????????
*/

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271Pagamento?Autor ?Vendas Clientes   ?Data ?0/05/00   ??
???????????????????????????????????????
??escri??o ?xecuta a tela com as condicoes de pagamento                 ??
???????????????????????????????????????
??intaxe   ?Tk271Pagamento(ExpN1, ExpL2,	 ExpA3,	 ExpC4,                ??
??         ?               ExpO5, ExpC6,  ExpC7,  ExpC8                 ??
??         ?               ExpO9, ExpC10, ExpC11, ExpC12,               ??
??         ?               ExpO13,ExpC14, ExpC15, ExpC16,               ??
??         ?               ExpO17,ExpC18, ExpC19, ExpC20,               ??
??         ?               Exp021,ExpC22, ExpO23, ExpC24,               ??
??         ?               Exp025,ExpC26, ExpO27, ExpC28,               ??
??         ?               ExpO29,ExpC30, ExpO31, ExpN32,               ??
??         ?               ExpO33,ExpN34, ExpO35, ExpN36,               ??
??         ?               ExpO37,ExpA38, ExpO39, ExpN40,               ??
??         ?               ExpO41,ExpN42, ExpO43, ExpN44,               ??
??         ?               ExpO45,ExpN46, ExpO47, ExpL48,               ??
??         ?               ExpO49,ExpN50, ExpC51, ExpL52)               ??
??         ?                                                            ??
???????????????????????????????????????
??arametros?ExpN1 = opcao selecionada pelo usuario                	   ??
??         ?ExpL2 = habilitar ou nao os objetos da tela de forma de     ??
??         ?pagamento - para que nao haja conflito com a tela Pai       ??
??         ?ExpA3 = dados complementares da parcela                     ??
??         ?ExpC4 = condicao de pagamento                               ??
??         ?ExpO5 = objeto msget da condicao de pagamento               ??
??         ?ExpC6 = descri?o da condicao de pagamento                  ??
??         ?ExpO7 = objeto msget da descri?o da condicao de pagamento  ??
??         ?ExpC8 = transportadora                                      ??
??         ?ExpO9 = objeto msget da transportadora                      ??
??         ?ExpC10= nome da transportadora                              ??
??         ?ExpO11= objeto msget do nome da transportadora              ??
??         ?ExpC12= endere? de cobran?                                ??
??         ?ExpO13= objeto msget do endere? de cobran?                ??
??         ?ExpC14= endere? de entrega                                 ??
??         ?ExpO15= objeto msget do endere? de entrega                 ??
??         ?ExpC16= cidade de cobran?                                  ??
??         ?ExpO17= objeto msget da cidade de cobran?                  ??
??         ?ExpC18= cep de cobran?                                     ??
??         ?ExpO19= objeto msget do cep de cobran?                     ??
??         ?ExpC20= estado de cobran?                                  ??
??         ?ExpO21= objeto msget do estado de cobran?                  ??
??         ?ExpC22= bairro de entrega                                   ??
??         ?ExpO23= objeto msget do bairro de entrega                   ??
??         ?ExpC24= bairro de cobran?                                  ??
??         ?ExpO25= objeto msget do bairro de cobran?                  ??
??         ?ExpC26= cidade de entrega                                   ??
??         ?ExpO27= objeto msget da cidade de entrega                   ??
??         ?ExpC28= cep de entrega                                      ??
??         ?ExpO29= objeto msget do cep de entrega                      ??
??         ?ExpC30= estado de entrega                                   ??
??         ?ExpO31= objeto msget do estado de entrega                   ??
??         ?ExpN32= valor liquido                                       ??
??         ?ExpO33= objeto msget para valor liquido                 	   ??
??         ?ExpN34= valor da taxa de juros                              ??
??         ?ExpO35= objeto msget valor da taxa de juros                 ??
??         ?ExpN36= taxa de desconto                                    ??
??         ?ExpO37= objeto msget taxa de desconto                       ??
??         ?ExpA38= array de parcelas                                   ??
??         ?ExpO39= objeto browse de parcelas                           ??
??         ?ExpN40= valor da entrada                                    ??
??         ?ExpO41= objeto msget com valor de entrada                   ??
??         ?ExpN42= valor financiado                                    ??
??         ?ExpO43= objeto msget com valor financiado                   ??
??         ?ExpN44= quantidade de parcelas                              ??
??         ?ExpO45= objeto msget com quantidade de parcelas             ??
??         ?ExpN46= valor do juros                                      ??
??         ?ExpC47= c?igo de pagamento carregado antes de qualquer     ??
??         ?atualiza?o                                                 ??
??         ?ExpL48= flag para condicao de pagto do tipo 9.              ??
??         ?ExpO49= objeto msget do valor nao faturado                  ??
??         ?ExpN50= valor nao faturado                                  ??
??         ?ExpC51= c?igo do cliente carregado antes de qualquer       ??
??         ?atualiza?o                                                 ??
??         ?ExpL52= flag para controle de integra?o com o SIGACRD      ??
??         ?ExpL53= flag para controle da regra de negocios             ??
???????????????????????????????????????
??so       ?TeleVendas                                                  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
/*
?????????????????????????????????????????????

ESSE PONTO DE ENTRADA SUBSTITUI A TELA DE SIMULAÇÃO DAS PARCELAS
DO CALL CENTER, ELE SUBSTITUI O FONTE TMKA273C, O FONTE É UMA COPIA SÓ ADICIONANDO
UMA VALIDAÇÃO PARA INCLUIR O FRETE SEMPRE NA PRIMEIRA PARCELA
A CUSTOMIAÇÃO ESTA SINALIZADA COMO UM COMENTÁRIO ELB
09/06/2020
																				 ?
?????????????????????????????????????????????
*/
User Function TMKVPA(	aValores		,aObj	    ,aItens		,cCodPagto		,;
						oCodPagto		,cDescPagto	,oDescPagto	,cCodTransp	,;
						oCodTransp		,cTransp	,oTransp	,cCob			,;
						oCob			,cEnt		,oEnt		,cCidadeC		,;
						oCidadeC		,cCepC		,oCepC		,cUfC			,;
						oUfC			,cBairroE	,oBairroE	,cBairroC		,;
						oBairroC		,cCidadeE	,oCidadeE	,cCepE			,;
						oCepE			,cUfE		,oUfE		,nLiquido		,;
						oLiquido		,nTxJuros	,oTxJuros	,nTxDescon		,;
						oTxDescon		,aParcelas	,oParcelas	,nEntrada		,;
						oEntrada		,nFinanciado,oFinanciado,nNumParcelas	,;
						oNumParcelas	,nVlJur		,nOpc		,cNumTlv		,;
						cCliente		,cLoja		,cCodCont	,cCodOper		,;
						cCliAnt        ,lTLVReg)

Local oDlgPagto         						       	// Tela de pagamento
Local lTMKCND  	:= FindFunction("U_TMKCND")				// P.E. para TLV na abertura da tela
//Local lTMKVPA  	:= FindFunction("U_TMKVPA")				// P.E. para TLV Substitui a funcao
Local lTMKVCPT 	:= FindFunction("T_TMKVCP")				// P.E. para TLV no final da funcao - Para uso exclusivo de Templates
Local lTMKVCP  	:= FindFunction("U_TMKVCP")				// P.E. para TLV no final da funcao
Local lTMKCPG	:= FindFunction("U_TMKCPG")				// P.E. executado antes da abertura da tela de pagamento para que se possa mudar a vari?el lHabilAux
Local oVlrPrazo                                         // objeto com o Total do pedido com a condicao
Local nVlrPrazo := 0									// Valor do Total do pedido com a condicao
Local nOpcA		:= 0									// Opcao da escolha OK ou CANCELA
//Local cNumTlv   := ""                                   // Codigo do atendimento TLV
Local cCliente  := ""									// Codigo do Cliente
Local cLoja     := ""                                   // Codigo da Loja
Local cCodCont  := ""                                   // Codigo do Contato
Local cCodOper  := ""                                   // Codigo do Operador
Local cTipoOper := ""                                   // Tipo de operacao("1-Faturamento;2-Orcamento;3-Atendimento")
Local oCurTmk           								// Objeto do CURSOR
Local lRet		:= .F.									// Retorno da funcao
Local cCodAnt   := M->UA_CONDPG  //ADICIONADO ELB
Local lTipo9    := .t.          //ADICIONADO  ELB
Local lSigaCRD
Local cPictTrans:= PesqPict("SUA","UA_TRANSP")			// Picture "Default" do campo de transportadora
//Local lHabilAux := lHabilita                            // Flag auxiliar para habilitar ou nao os objetos da tela de forma de pagamento - para que nao haja conflito com a tela Pai
Local lHabilAux := .t.
Local lHabilita       := .t.
Local lTefMult	:= SuperGetMV("MV_TEFMULT")				// Parametro do SX6 que indica se o sistema vai o TEF multiplas transacoes
Local aArea		:= GetArea()							// Salva a area atual
Local lTMKFIS	:= GetNewPar("MV_TMKFIS",.T.)			// (N? divulgar) Parametro que indica que a atualiza?o da MATXFIS ?feita de maneira on-line, no off-line a MATXFIS s??atualizada quando se entra na condi?o de pagamento.
Local oFolder		:= Nil								// Objeto TFolder com os folder quando o atendimento televendas ?off-line
Local oFolderPagto	:= Nil								// Quando o atendimento televendas ?off-line, ter?a aba da condi?o de pagamento, quando o atendimento for on-line ter?o dialog da condi?o de pagamento.
Local oFis			:= Nil								// Objeto com os impostos
Local lTLVReg1		:= IIF(ValType(lTLVReg) <>	"L",.F.,lTLVReg)	// controle de validacao da regra de negocios
Local lTLVReg2		:= IIF(ValType(lTLVReg) <>	"L",.F.,lTLVReg)	// controle de validacao da regra de negocios
Local aDadosCompl	:= {}								// Guarda os campos dos dados complementares
Local aInfoSx3      := {}								// Array que possui as informa?es do SX3

DEFINE CURSOR oCurTmk HAND								// Muda o cursor para "Hand"

//??????????????????????????????
//?incroniza os campos, caso as variaveis passadas pelo par?
//?etro n? foram atualizadas pelo objeto.                  ?
//??????????????????????????????
If (Type("M->UA_CONDPG") <> "U") .And. (cCodPagto <> M->UA_CONDPG)
	cCodPagto := M->UA_CONDPG
Endif

//????????????????????????
//?erifica se o campo UA_TRANSP ?visualiz?el.?
//????????????????????????
DbSelectArea("SX3")
DbSetOrder(2)

If ( DbSeek( "UA_TRANSP" ) ) .AND. SX3->X3_BROWSE == "S"
	If (cCodTransp <> M->UA_TRANSP)
		cCodTransp := M->UA_TRANSP
		Tk273AtuTransp(cCodTransp,@cTransp,oTransp)
	Endif
EndIf
RestArea(aArea)

//????????????????????????
//?alida se a picture da transportadora esta OK?
//????????????????????????
If Empty(cPictTrans)
	cPictTrans := "@!"
Endif

//???????????????????????
//?Guarda os dados complementares originais. ?
//???????????????????????
aDadosCompl := {cCodTransp	,cTransp	,cCob		,cEnt		,;
				cCidadeC	,cCepC		,cUfC		,cBairroE	,;
				cBairroC	,cCidadeE	,cCepE		,cUfE		,;
				cCliAnt}

//??????????????????????????????
//?e o par?etro MV_TMKFIS estiver falso, significa que     ?
//? Televendas est?trabalhando em modo off-line, ou seja,  ?
//?omente quando abrir a tela de condi?o de pagamento,     ?
//? MATXFIS ser?atualizadada. (N? divulgar)               ?
//??????????????????????????????
If !lTMKFIS

	Tk273RecCpg()
	Tk273AtuNFs()


	aValores[MERCADORIA] := MaFisRet(, "NF_VALMERC")
	aValores[SUFRAMA] 	 := MaFisRet(, "NF_DESCZF")
	aValores[TOTAL] 	 := MaFisRet(, "NF_TOTAL")
	aValores[BASEDUP] 	 := MaFisRet(, "NF_BASEDUP")

EndIf

//???????????????????
//?alida se existem produtos lancados?
//???????????????????
If aValores[TOTAL] <= 0

	//???????????????????????????????????????????????????????????
	//?e o flag para nao gerar titulo, poder lancar quantidade e valor total = 0,00 estiver TRUE: NAO FECHA O ATENDIMENTO?
	//???????????????????????????????????????????????????????????
	If lTesTit
		//??????????????????????
		//?e nao estiver usando a entrada automatica?
		//??????????????????????
		If !lTk271Auto
			Help(" ",1,"SEMDADOS")
		Endif
		Return(lRet)

	Else

		//????????????????????????????????????????????????????
		//?e o atendiment vai gerar duplicata, ou a TES esta configurada para que o valor do pedido seja > 0,00?
		//????????????????????????????????????????????????????
		If (Type("M->UA_CONDPG") <> "U")
			If Empty(M->UA_CONDPG) .AND. Empty(cCodPagto)
				Help(" ",1,"FALTA_PGTO")
				Return(lRet)
			Endif
		Else
			Return(lRet)
		EndIf
	Endif
Endif

//???????????????????????????????
//?ssa funcao esta acessivel somente para a tela de Televendas?
//???????????????????????????????
If (nFolder == 1 .AND. (TkGetTipoAte() == "2" .OR. TkGetTipoAte() == "4")) .OR. (nFolder == 2) //Televendas
	cNumTlv   := M->UA_NUM
	cCliente  := M->UA_CLIENTE
	cLoja     := M->UA_LOJA
	cCodCont  := M->UA_CODCONT
	cCodOper  := M->UA_OPERADO
	cTipoOper := M->UA_OPER
Endif

nLiquido 	:= aValores[BASEDUP]
nValNFat	:= aValores[TOTAL] - aValores[BASEDUP]
nLiquido	:= aValores[BASEDUP] - aValores[ACRESCIMO]
nSuframa	:= aValores[SUFRAMA]
nTotal		:= aValores[TOTAL]

/*
If lTMKVPA
	lRet := U_TMKVPA(	@aValores		,@aObj			,@aItens		,@cCodPagto		,;
						oCodPagto		,@cDescPagto	,@oDescPagto	,@cCodTransp	,;
						@oCodTransp		,@cTransp		,@oTransp		,@cCob			,;
						@oCob			,@cEnt			,@oEnt			,@cCidadeC		,;
						@oCidadeC		,@cCepC			,@oCepC			,@cUfC			,;
						@oUfC			,@cBairroE		,@oBairroE		,@cBairroC		,;
						@oBairroC		,@cCidadeE		,@oCidadeE		,@cCepE			,;
						@oCepE			,@cUfE			,@oUfE			,@nLiquido		,;
						@oLiquido		,@nTxJuros		,@oTxJuros		,@nTxDescon		,;
						@oTxDescon		,@aParcelas		,@oParcelas		,@nEntrada		,;
						@oEntrada		,@nFinanciado	,@oFinanciado	,@nNumParcelas	,;
						@oNumParcelas	,@nVlJur		,nOpc			,cNumTlv		,;
						cCliente		,cLoja			,cCodCont		,cCodOper		,;
						@cCliAnt        ,@lTLVReg)
	Return(lRet)
Endif */

If lTMKCPG
	U_TMKCPG( @lHabilAux )
EndIf

//?????????????????????????
//?aso o nOpc = 2 (visualizacao), nao e habilitado?
//? campo de condicao de pagamento.               ?
//?????????????????????????
If nOpc == 2
	lHabilita := .F.
EndIf
//????????????????????????????????
//?uando for feita inclusao de novo GET na tela de condicao de ?
//?agamento, nao esquecer de incluir novo GET no array         ?
//?ValidGet e se o mesmo possuir uma funcao de validacao,      ?
//?dapta-la a rotina de entrada automatica e incluir essa      ?
//?uncao no array aVldBlock.                                   ?
//????????????????????????????????
//??????????????????????
//?e nao estiver usando a entrada automatica?
//??????????????????????
If !lTk271Auto

	if M->UA_ZNEGPRE == "2" .Or. !Empty(M->UA_ZNPDTRE)
		lHabilita := .F.
	endif

	//Carregando informa?es das propriedades dos campos do sx3 para aplicar nos MSGET
	aInfoSx3 := TK273LdSx3()

	DEFINE MSDIALOG oDlgPagto FROM  23,80 TO IF(!lTMKFIS,495,465),710 TITLE 'Forma de Pagamento' PIXEL STYLE DS_MODALFRAME //"Forma de Pagamento"

		//???????????????????????????????
		//?e for televendas off-line, cria folder de imposto, j?que o?
		//?esmo n? ?exibido no atendimento.                         ?
		//???????????????????????????????
		If !lTMKFIS
			oFolder := TFolder():New(01, 01,{'Cond.Pagto', 'Impostos'}, {"HEADER", "HEADER"},oDlgPagto,,,,.T.,.F.,0, 0,) // "Cond. Pagto" "Impostos"
			oFolder:Align := CONTROL_ALIGN_ALLCLIENT
			oFolder:aDialogs[1]:oFont := oDlgPagto:oFont
			oFolder:aDialogs[2]:oFont := oDlgPagto:oFont
			oFis := MaFisRodape(1,oFolder:aDialogs[2],,{01,01,0,0},bListRefresh,.T.)
			oFis:Align := CONTROL_ALIGN_ALLCLIENT
			oFolderPagto :=	oFolder:aDialogs[1]
		Else
			oFolderPagto := oDlgPagto
		EndIf

		@ 003,002 TO 115,310 LABEL 'Condi??es de Pagamento' OF oFolderPagto  PIXEL //"Condi??es de Pagamento"


		@ 011,004 SAY 'Condicao' OF oFolderPagto PIXEL  //"Condi??o"
		@ 011,040 MSGET oCodPagto VAR cCodPagto SIZE 30,8 OF oFolderPagto PIXEL F3 X3F3("UA_CONDPG") Picture "@!" WHEN lHabilita ;
					VALID MsgRun('Mensagem',"",{|| RecDesc6(nLiquido,cCodPagto),oParcelas:Disable(),Tk273MontaParcela(	nOpc		,cNumTlv	,@nLiquido		,oLiquido		,;
												 				   						@nTxJuros	,oTxJuros	,@nTxDescon		,oTxDescon		,;
																						@aParcelas	,oParcelas	,@cCodPagto		,oCodPagto		,;
																						@nEntrada	,oEntrada	,@nFinanciado	,oFinanciado	,;
																						@cDescPagto	,oDescPagto	,@nNumParcelas	,oNumParcelas	,;
																						@nVlrPrazo	,oVlrPrazo	,@nVlJur		,@cCodAnt		,;
																						@lTipo9		,nValNFat	,oValNFat		,.T.			,;
																						oFis		,@nSuframa	,oSuframa		,@nTotal		,;
																						oTotal		,@lTLVReg1  ,@lTLVReg2),;
							oParcelas:Enable(),.T.})
					//VALID IIF(VldDesc(cCodPagto),MsgRun('Mensagem',"",{|| RecDesc6(nLiquido,cCodPagto),oParcelas:Disable(),Tk273MontaParcela(	nOpc		,cNumTlv	,@nLiquido		,oLiquido		,;
					//							 				   						@nTxJuros	,oTxJuros	,@nTxDescon		,oTxDescon		,;
					//																	@aParcelas	,oParcelas	,@cCodPagto		,oCodPagto		,;
					//																	@nEntrada	,oEntrada	,@nFinanciado	,oFinanciado	,;
					//																	@cDescPagto	,oDescPagto	,@nNumParcelas	,oNumParcelas	,;
					//																	@nVlrPrazo	,oVlrPrazo	,@nVlJur		,@cCodAnt		,;
					//																	@lTipo9		,nValNFat	,oValNFat		,.T.			,;
					//																	oFis		,@nSuframa	,oSuframa		,@nTotal		,;
					//																	oTotal		,@lTLVReg1  ,@lTLVReg2),;
					//		oParcelas:Enable(),.T.}),.F.)
		oCodPagto:cSX1Hlp := "UA_CONDPG"

		@ 011,070 SAY oDescPagto VAR cDescPagto Picture "@!" SIZE 50,8 OF oFolderPagto PIXEL COLOR CLR_BLUE

		@ 021,004 SAY 'Valor nao faturado'  OF oFolderPagto PIXEL  //"Valor Nao Faturado"
		@ 021,040 MSGET oValNFat VAR nValNFat Picture "@E 999,999,999.99" SIZE 55,8  OF oFolderPagto PIXEL When .F.

		@ 031,004 SAY 'Liquido' OF oFolderPagto PIXEL //"L?uido"
		@ 031,040 MSGET oLiquido VAR nLiquido Picture "@E 999,999,999.99" SIZE 55,8 OF oFolderPagto PIXEL When .F.

		@ 041,004 SAY 'Entrada' OF oFolderPagto PIXEL //"Entrada"
		@ 041,040 MSGET oEntrada VAR nEntrada Picture "@E 999,999,999.99" SIZE 55,8  OF oFolderPagto PIXEL When .F.

		@ 051,004 SAY 'Juros' OF oFolderPagto PIXEL //"Juros"
		@ 051,040 MSGET oTxJuros VAR nTxJuros  Picture "@E 999.99" SIZE 15,8 OF oFolderPagto PIXEL When .F.

		@ 051,073 SAY 'Parcelas' OF oFolderPagto PIXEL //"Parcelas"
		@ 051,095 MSGET oNumParcelas VAR nNumParcelas Picture "99"  SIZE 17,8  OF oFolderPagto PIXEL When .F.

		@ 061,004 SAY 'Financeiro' OF oFolderPagto PIXEL //"Financiado"
		@ 061,040 MSGET oFinanciado VAR nFinanciado Picture "@E 999,999,999.99" SIZE 55,8  OF oFolderPagto PIXEL When .F.

		@ 071,004 SAY 'Total Fat.' OF oFolderPagto PIXEL // "Total Fat."
		@ 071,040 MSGET oVlrPrazo VAR nVlrPrazo Picture "@E 999,999,999.99"  SIZE 55,8  OF oFolderPagto PIXEL When .F.

		@ 081,004 SAY 'Total Ped.' OF oFolderPagto PIXEL // "Total Ped."
		@ 081,040 MSGET oTotal VAR nTotal Picture "@E 999,999,999.99"  SIZE 55,8  OF oFolderPagto PIXEL When .F.

		@ 091,004 SAY 'Suframa' OF oFolderPagto PIXEL // "Suframa"
		@ 091,040 MSGET oSuframa VAR nSuframa Picture "@E 999,999,999.99" SIZE 55,8  OF oFolderPagto PIXEL When .F.

		@ 101,004 SAY 'Desconto' OF oFolderPagto PIXEL //"Desconto"
		@ 101,040 MSGET oTxDescon VAR nTxDescon Picture "@E 999.99" SIZE 20,8  OF oFolderPagto PIXEL When .F.

		//???????????????????????????????????
		//?istbox com as parcelas de pagamento conforme a condicao escolhida  ?
		//???????????????????????????????????
		@09,125 BROWSE oParcelas SIZE 180,102 OF oFolderPagto PIXEL ;
				ON DbLCLICK Tk273Detalhe(	@aParcelas	,oParcelas	,@aItens	,lHabilita,;
											nLiquido	,@nEntrada	,oEntrada	,@nFinanciado,;
											oFinanciado	,cCodPagto	,lSigaCRD   ,@lTLVReg2 )

		// Visualizacao das parcelas
		oParcelas:SetArray( aParcelas )
		ADD COLUMN TO oParcelas HEADER 'Data' OEM DATA {|| DTOC(aParcelas[oParcelas:nAt,1]) }  					  	ALIGN LEFT SIZE 40 PIXEL //"Data"
		ADD COLUMN TO oParcelas HEADER 'Valor' OEM DATA {|| Transform(aParcelas[oParcelas:nAt,2],"@E 999,999,999.99")}  ALIGN LEFT SIZE 55 PIXEL //"Valor"
		ADD COLUMN TO oParcelas HEADER 'Forma' OEM DATA {|| aParcelas[oParcelas:nAt,3] } 								ALIGN LEFT SIZE 40 PIXEL //"Forma"
		oParcelas:oCursor := oCurTmk

		//?????????????????????????????????????????
		//?rowse com as parcelas de pagamento (Sintetizada) conforme a condicao escolhida ?
		//?sta forma de visualizacao sera usada somente quando for TEF com ClisiTef       ?
		//?????????????????????????????????????????
		If 	lVisuSint 	.AND.;
		 	lUsaTef 	.AND.;
		 	cTipTef == TEF_CLISITEF

			@09,115 BROWSE oPgtosSint SIZE 190,82 OF oFolderPagto PIXEL ;
					ON DbLCLICK Tk273DetSint(	@aParcelas	,oParcelas	,@aItens	,lHabilita,;
												nLiquido	,@nEntrada	,oEntrada	,@nFinanciado,;
												oFinanciado	,cCodPagto	,lSigaCRD	,oDlgPagto)
			//????????????????????????????????
			//?Estrutura do array aPgtosSint                                ?
			//????????????????????????????????
			//?[1] - Forma de Pagamento                                     ?
			//?[2] - Qtde de Parcelas da forma de pagto                     ?
			//?[3] - Valor total desta forma de pagamento                   ?
			//| [4] - Sequencia para controle de m?tiplas transa?ies		 |
			//?[5] - Data da primeira parcela                               ?
			//?[6] - Codigo da Administradora financeira                    ?
			//????????????????????????????????
			oPgtosSint:SetArray( aPgtosSint )
			ADD COLUMN TO oPgtosSint HEADER 'Data'	OEM DATA { || aPgtosSint[oPgtosSint:nAt,5] } ALIGN LEFT  SIZE 40 PIXEL 	//"Data"
			ADD COLUMN TO oPgtosSint HEADER 'Forma'	OEM DATA { || aPgtosSint[oPgtosSint:nAt,1] } ALIGN LEFT  SIZE 40 PIXEL 	//"Forma Pgto"
			ADD COLUMN TO oPgtosSint HEADER 'Valor'	OEM DATA { || aPgtosSint[oPgtosSint:nAt,3] } ALIGN LEFT  SIZE 55 PIXEL  //"Valor"
			ADD COLUMN TO oPgtosSint HEADER 'Parcelas'	OEM DATA { || aPgtosSint[oPgtosSint:nAt,2] } ALIGN LEFT  SIZE 30 PIXEL 	//"Parcelas"

			//So inserir a coluna ID Cartao quando o cliente trabalhar com multiplas transacoes TEF
			If lUsaTef .AND. lTefMult
				ADD COLUMN TO oPgtosSint HEADER 'ID Cartao'		OEM DATA { || aPgtosSint[oPgtosSint:nAt,4] } ALIGN LEFT  SIZE 30 PIXEL  //"ID Cartao"
			Endif

			oPgtosSint:oCursor := oCurTmk
		Endif

		oEntrada:Refresh()
		oLiquido:Refresh()
		oFinanciado:Refresh()

		@ 120,002 TO 205,310 LABEL 'Dados Complementares' OF oFolderPagto  PIXEL 	// "Dados Complementares"

		@ 131,004 SAY 'Transportadora' OF oFolderPagto PIXEL 				// "Transportadora"
		@ 131,045 MSGET oCodTransp VAR cCodTransp Picture cPicttrans F3 X3F3("UA_TRANSP") SIZE 40,8 OF oFolderPagto PIXEL ;
					Valid Tk273AtuTransp(cCodTransp,@cTransp,oTransp) When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_TRANSP"}),2])
		oCodTransp:cSX1Hlp := "UA_TRANSP"

		@ 130,090 SAY oTransp VAR cTransp Picture "@!" SIZE 150,16 OF oFolderPagto PIXEL COLOR CLR_BLUE

		@ 146,004 SAY 'Cobranca' OF oFolderPagto PIXEL  //"Cobranca"
		@ 146,045 MSGET oCob VAR cCob  Picture "@!" SIZE 115,8  OF oFolderPagto PIXEL When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_ENDCOB"}),2])
		oCob:cSX1Hlp := "UA_ENDCOB"

		@ 146,180 SAY 'Bairro' OF oFolderPagto PIXEL //"Bairro"
		@ 146,205 MSGET oBairroC VAR cBairroC Picture "@!" SIZE 80,8 OF oFolderPagto PIXEL When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_BAIRROC"}),2])
		oBairroC:cSX1Hlp := "UA_BAIRROC"

		@ 161,004 SAY 'Cidade' OF oFolderPagto PIXEL //"Cidade"
		@ 161,045 MSGET oCidadeC VAR cCidadeC Picture "@!" SIZE 80,8 OF oFolderPagto PIXEL ;
					Valid Tk273CidC(@oCidadeC,@cCidadeC) When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_MUNC"}),2])
		oCidadeC:cSX1Hlp := "UA_MUNC"

		@ 161,150 SAY 'CEP' OF oFolderPagto PIXEL //"CEP"
		@ 161,170 MSGET oCepC VAR cCepC Picture "@R 99999-999" SIZE 40,8 OF oFolderPagto PIXEL Valid ;
					Tk273CepC(	@cCepC	,@oCepC	,@cCidadeC	,@oCidadeC,;
								@cUfC	,@oUfC	,@cBairroC	,@oBairroC);
					When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_CEPC"}),2])
		oCepC:cSX1Hlp := "UA_CEPC"

		@ 161,225 SAY 'Estado' SIZE 25,8 OF oFolderPagto PIXEL  //"Estado"
		@ 161,250 MSGET oUfC VAR cUfC Picture "@!" F3 "12" SIZE 35,8 OF oFolderPagto PIXEL Valid Tk273Estado(cUfc) When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_ESTC"}),2])
		oUfC:cSX1Hlp := "UA_ESTC"

		@ 176,004 SAY 'Entrega' OF oFolderPagto PIXEL  //"Entrega"
		@ 176,045 MSGET oEnt VAR cEnt Picture "@!" SIZE 115,8 OF oFolderPagto PIXEL When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_ENDENT"}),2])
		oEnt:cSX1Hlp := "UA_ENDENT"

		@ 176,180 SAY 'Bairro' OF oFolderPagto PIXEL  //"Bairro"
		@ 176,205 MSGET oBairroE VAR cBairroE Picture "@!" SIZE 80,8 OF oFolderPagto PIXEL When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_BAIRROE"}),2])
		oBairroE:cSX1Hlp := "UA_BAIRROE"

		@ 191,004 SAY 'Cidade' OF oFolderPagto PIXEL  //"Cidade"
		@ 191,045 MSGET oCidadeE VAR cCidadeE Picture "@!"  SIZE 80,8 OF oFolderPagto PIXEL Valid ;
					Tk273CidE(@oCidadeE,@cCidadeE) When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_MUNE"}),2])
		oCidadeE:cSX1Hlp := "UA_MUNE"


		@ 191,150 SAY 'CEP' OF oFolderPagto PIXEL //"CEP"
		@ 191,170 MSGET oCepE VAR cCepE  Picture "@R 99999-999"	SIZE 40,8 OF oFolderPagto PIXEL Valid ;
					Tk273CepE(	@cCepE	,@oCepE	,@cCidadeE	,@oCidadeE,;
								@cUfE	,@oUfE	,@cBairroE	,@oBairroE);
					When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_CEPE"}),2])
		oCepE:cSX1Hlp := "UA_CEPE"

		@ 191,225 SAY 'Estado' SIZE 25,8 OF oFolderPagto PIXEL //"Estado"
		@ 191,250 MSGET oUfE VAR cUfE Picture "@!" F3 "12"  SIZE 35,8 OF oFolderPagto PIXEL Valid Tk273Estado(cUfe) When IIF(lTMKCPG, lHabilAux, aInfoSx3[aScan(aInfoSx3,  {|x| x[1] == "UA_ESTE"}),2])

		//????????????????????????????????????????????
		//?e for VISUALIZACAO nao precisa habilitar o botao de OK - nao havera novas manutencoes?
		//????????????????????????????????????????????
		If lHabilita .or. nOpc<>2
			DEFINE SBUTTON FROM 207,240 TYPE 1;
				 ACTION (nOpcA := 1,lRet := IIF(	Tk273ParcelaOk(	aParcelas	,nEntrada	,nFinanciado	,nValNFat	,;
																	cTipoOper	,cCodPagto	,cCodTransp		,cCob		,;
																	cEnt		,cCidadeC	,cCepC			,cBairroC	,;
																	cBairroE	,cCidadeE	,cCepE			,cUfE 		,;
																	@cTransp	,oTransp) .AND.;
													MaVldTabPrc( M->UA_TABELA, cCodPagto ),;
												oDlgPagto:End(),;
												""));
												ENABLE OF oFolderPagto
	    Endif

		DEFINE SBUTTON FROM 207,280 TYPE 2 ACTION (sfAtuDesc(),lRet := .F.,oDlgPagto:End()) ENABLE OF oFolderPagto

		// Desabilita a tecla ESC
	    oDlgPagto:LESCCLOSE := .F.

	ACTIVATE MSDIALOG oDlgPagto CENTERED ON INIT MsgRun('Mensagem',"",{||	(Tk273InitPagto(	cNumTlv		,cCliente	,cLoja		,nOpc,;
																	   						@cCodPagto	,oCodPagto	,@cDescPagto,oDescPagto,;
																							@cCodTransp	,oCodTransp	,@cTransp	,oTransp,;
																							@cCob		,oCob		,@cEnt		,oEnt,;
																							@cCidadeC	,oCidadeC	,@cCepC		,oCepC,;
																							@cUfC		,oUfC		,@cBairroE	,oBairroE,;
																							@cBairroC	,oBairroC	,@cCidadeE	,oCidadeE,;
																							@cCepE		,oCepE		,@cUfE		,oUfE,;
																							@cCliAnt   ),;
																  		IIF(!Tk273CompVal(	@aParcelas	, nLiquido	, nVlJur	, cCodPagto	,;
																  							cCodAnt		),;
																		Tk273MontaParcela(	nOpc		,cNumTlv		,@nLiquido		,oLiquido		,;
																		 					@nTxJuros	,oTxJuros		,@nTxDescon		,oTxDescon		,;
											 												@aParcelas	,oParcelas		,@cCodPagto		,oCodPagto		,;
																			 				@nEntrada	,oEntrada		,@nFinanciado	,oFinanciado	,;
																							@cDescPagto	,oDescPagto		,@nNumParcelas	,oNumParcelas	,;
																							@nVlrPrazo	,oVlrPrazo		,@nVlJur		,@cCodAnt		,;
																							@lTipo9		,nValNFat		,oValNFat		,.F.			,;
																							oFis		,@nSuframa		,oSuframa		,@nTotal		,;
																							oTotal		,@lTLVReg1      ,@lTLVReg2  		  		   ),;
																		( nVlrPrazo := nEntrada + nFinanciado, If(!lTk271Auto,oVlrPrazo:Refresh(),) ) ),;
																		IIF(lTMKCND,;
																			U_TMKCND(	cNumTlv		,cCliente		,cLoja			,cCodCont,;
																						cCodOper	,@aParcelas		,@cCodPagto		,oCodPagto,;
																						@cDescPagto	,@oDescPagto 	,@lHabilAux		,@cCodTransp) ,"") )})
Endif

//Confirmou a condicao atualiza o rodape, caso haja acrescimo na condicao
If nOpcA == 1
	aParcTef	:= AClone(aParcelas)
	M->UA_CONDPG:= cCodPagto
	M->UA_TRANSP:= cCodTransp
ElseIf nOpcA == 0
	//Caso o usu?io cancele a janela do pagamento, retorna os dados complementares anteriores.
	cCodTransp 	:= aDadosCompl[1]
	cTransp 	:= aDadosCompl[2]
	cCob 		:= aDadosCompl[3]
	cEnt 		:= aDadosCompl[4]
	cCidadeC 	:= aDadosCompl[5]
	cCepC 		:= aDadosCompl[6]
	cUfC 		:= aDadosCompl[7]
	cBairroE 	:= aDadosCompl[8]
	cBairroC 	:= aDadosCompl[9]
	cCidadeE 	:= aDadosCompl[10]
	cCepE 		:= aDadosCompl[11]
	cUfE 		:= aDadosCompl[12]
	cCliAnt     := aDadosCompl[13]

	//Zera parcelas quando tela e cancelada
	aParcelas 	:= {}

Endif

lTLVReg := (lTLVReg1 .Or. lTLVReg2 ) //retorno das validacoes da regra de negocios

//??????????????????????????????????????
//?onto de Entrada para uso em Templates									?
//??????????????????????????????????????
If lTMKVCPT
	If T_TMKVCP(@cCodTransp	,@oCodTransp	,@cTransp	,@oTransp,;
				@cCob		,@oCob			,@cEnt		,@oEnt,;
				@cCidadeC	,@oCidadeC		,@cCepC		,@oCepC,;
				@cUfC		,@oUfC			,@cBairroE	,@oBairroE,;
				@cBairroC	,@oBairroC		,@cCidadeE	,@oCidadeE,;
				@cCepE		,@oCepE			,@cUfE		,@oUfE,;
				nOpc		,cNumTlv		,cCliente	,cLoja,;
				cCodPagto	,aParcelas)
		lRet := .T.
	 	Return(lRet)
	Else
		Return(lRet)
	Endif
Endif
If lTMKVCP
	If U_TMKVCP(@cCodTransp	,@oCodTransp	,@cTransp	,@oTransp,;
				@cCob		,@oCob			,@cEnt		,@oEnt,;
				@cCidadeC	,@oCidadeC		,@cCepC		,@oCepC,;
				@cUfC		,@oUfC			,@cBairroE	,@oBairroE,;
				@cBairroC	,@oBairroC		,@cCidadeE	,@oCidadeE,;
				@cCepE		,@oCepE			,@cUfE		,@oUfE,;
				nOpc		,cNumTlv		,cCliente	,cLoja,;
				cCodPagto	,aParcelas)
		lRet := .T.
	 	Return(lRet)
	Else
		Return(lRet)
	Endif
Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271InitPagto ?Autor ?Vendas Clientes  ?Data ?7/12/01  ??
???????????????????????????????????????
??escri??o ?tualiza os dados da condicao de pagamento no INIT da tela  ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273InitPagto( cNumTlv,   cCliente,	cLoja,		nOpc,;
						cCodPagto,	oCodPagto,	cDescPagto,	oDescPagto,;
						cCodTransp,	oCodTransp,	cTransp,	oTransp,;
						cCob,		oCob,		cEnt,		oEnt,;
						cCidadeC,	oCidadeC,	cCepC,		oCepC,;
						cUfC,		oUfC,		cBairroE,	oBairroE,;
						cBairroC,	oBairroC,	cCidadeE,	oCidadeE,;
						cCepE,		oCepE,		cUfE,		oUfE,;
						cCliAnt )

Local cCondPad 	:= ""													// Condicao de Pagamento Padrao
Local cParCond	:= SuperGetMv("MV_CONDPAD")								// Conteudo do parametro MV_CONDPAD


//???????????????
//?osicoes do array aRetTrans ?
//?- Codigo da Transportadora ?
//?- Codigo da Cond. Pagto	   ?
//?- Endereco  			   ?
//?- Bairro    			   ?
//?- Cep    				   ?
//?- Uf    				   ?
//???????????????
If Empty(M->UA_CONDPG)
	cCondPad 	:= cParCond + Space(3-Len(cParCond))
Else
	cCondPad 	:= M->UA_CONDPG
EndIf

//????????????????????????
//?erifica se o campo UA_TRANSP ?visualiz?el.?
//????????????????????????
DbSelectArea("SX3")
DbSetOrder(2)

If ( DbSeek( "UA_TRANSP" ) ) .AND. SX3->X3_BROWSE == "S"
	If (cCodTransp <> M->UA_TRANSP)
		cCodTransp := M->UA_TRANSP
		Tk273AtuTransp(cCodTransp,@cTransp,oTransp)
	Endif
EndIf

//??????????????????????????????????????????
//?e o atendente ainda nao escolheu uma condicao de pagamento pega a condicao do SA1?
//?u se o operador alterou o CLIENTE/PROSPECT no atendimento atualiza os enderecos  ?
//??????????????????????????????????????????
If Empty(cCodPagto) .OR. (cCliAnt <> cCliente+cLoja)

	//???????????????????
	//?tualiza o codigo do cliente antigo?
	//???????????????????
	cCliAnt := cCliente+cLoja

	//????????????????????????????????????????
	//?rocura pelos campos de endereco (entrega e cobranca) somente para CLIENTES   ?
	//????????????????????????????????????????
	If !lProspect
		DbSelectArea("SA1")
		DbSetOrder(1)
		If DbSeek(xFilial("SA1")+cCliente+cLoja)

			//??????????
			//?ados para entrega?
			//??????????
			If AllTrim(Upper(SA1->A1_ENDENT)) == "O MESMO"
				cEnt    :=SA1->A1_END
				cCidadeE:=SA1->A1_MUN
				cCepE   :=SA1->A1_CEP
				cUfE    :=SA1->A1_EST
				cBairroE:=SA1->A1_BAIRRO
			Else
				cEnt    :=SA1->A1_ENDENT
				cCidadeE:=SA1->A1_MUNE
				cCepe   :=SA1->A1_CEPE
				cUfe    :=SA1->A1_ESTE
				cBairroE:=SA1->A1_BAIRROE
			Endif

			//??????????
			//?ados de cobranca?
			//??????????
			If AllTrim(UPPER(SA1->A1_ENDCOB)) = "O MESMO"
				cCob    :=SA1->A1_END
				cCidadeC:=SA1->A1_MUN
				cCepC   :=SA1->A1_CEP
				cUfC    :=SA1->A1_EST
				cBairroc:=SA1->A1_BAIRRO
			Else
				cCob    :=SA1->A1_ENDCOB
				cCidadeC:=SA1->A1_MUNC
				cCepC   :=SA1->A1_CEPC
				cUfC    :=SA1->A1_ESTC
				cBairroC:=SA1->A1_BAIRROC
			Endif

			//?????????????????
			//?ondicao de pagamento utilizada?
			//?????????????????
			If !Empty(M->UA_CONDPG)
				cCondPad := M->UA_CONDPG
			ElseIf !Empty(SA1->A1_COND)
				cCondPad := SA1->A1_COND
			Endif
			cCodPagto  := cCondPad

			//??????????????????????????
			//?o pega a transportadora do cliente, se nenhuma   ?
			//?ransportadora for selecionada antes.             ?
			//?So funciona quando o campo UA_TRANSP estiver como?
			//?Usado") e tambem ja faz a gravacao na memoria    ?
			//?ara evitar que se pressionado cancelar nao grave ?
			//?ssa informacao, ja que o cliente podera nao ser  ?
			//?lterado deixando o campo UA_TRANSP em branco.    ?
			//??????????????????????????
			If Empty(cCodTransp)
                cCodTransp := M->UA_TRANSP := SA1->A1_TRANSP
            EndIf

		Endif
	Else
		//??????????????????????????????????????????????
		//? cadastro de Prospect nao tem condicao de pagamento Default por isso assume o parametro  ?
		//??????????????????????????????????????????????
		cCodPagto := cCondPad
	Endif

	//????????????????????
	//?ega o nome da condi?o de pagamento.?
	//????????????????????
	cDescPagto := ""
	DbSelectArea("SE4")
	DbSetOrder(1)
	If DbSeek(xFilial("SE4")+cCondPad)
		cDescPagto:= SE4->E4_DESCRI
	Else
		DbSeek(xFilial("SE4"))
		cCondPad 	:= SE4->E4_CODIGO
		cCodPagto	:= SE4->E4_CODIGO
		cDescPagto	:= SE4->E4_DESCRI
	Endif

Else

	If (nOpc == 4) .OR. (nOpc == 2) // Alterar ou Visualizar
		DbSelectArea("SUA")
		DbSetOrder(1)
		If DbSeek(xFilial("SUA")+cNumTlv)

			//????????????????????????????????????????????????????
			//?uma altera??o: A condi??o pode ou n?o ter sido informada anteriormente verifico isso pelo UA_COND   ?
			//????????????????????????????????????????????????????
			If !Empty(SUA->UA_CONDPG)
				//?????????????????????????????????????????????
				//?e as variaveis estiverem vazias o Operador nao alterou o conteudo da forma de pagamento?
				//?????????????????????????????????????????????
				If Empty(cCodPagto) .AND. Empty(cDescPagto)

					nEntrada   := SUA->UA_ENTRADA
					nTxJuros   := SUA->UA_JUROS    	// percentual de juros
					nVlJur	   := SUA->UA_ACRECND  	// valor do juros
					nTxDescon  := SUA->UA_TXDESC	// percentual de desconto
					nParcelas  := SUA->UA_PARCELA
					nFinanciado:= SUA->UA_FINANC

					DbSelectArea("SE4")
					DbSetOrder(1)
					If DbSeek(xFilial("SE4")+SUA->UA_CONDPG)
						cCodPagto := SE4->E4_CODIGO
						cDescPagto:= SE4->E4_DESCRI
					Endif

					If Empty(cCodTransp) .OR. Empty(cTransp)
						DbSelectArea("SA4")
						DbSetOrder(1)
						If DbSeek(xFilial("SA4")+SUA->UA_TRANSP)
							cCodTransp 	:= SUA->UA_TRANSP
							cTransp		:= SA4->A4_COD+"-"+SA4->A4_NOME
						Endif
					Endif

					cCob    :=SUA->UA_ENDCOB
					cEnt    :=SUA->UA_ENDENT
					cCidadeC:=SUA->UA_MUNC
					cCepC   :=SUA->UA_CEPC
					cUfC    :=SUA->UA_ESTC
					cBairroC:=SUA->UA_BAIRROC

					cCidadeE:=SUA->UA_MUNE
					cCepE   :=SUA->UA_CEPE
					cUfE    :=SUA->UA_ESTE
					cBairroE:=SUA->UA_BAIRROE
				Endif
			Else
				//??????????????????????????????????????????????
				//? cadastro de Prospect nao tem condicao de pagamento Defatult por isso assume o parametro ?
				//??????????????????????????????????????????????
				cCodPagto := cCondPad
			Endif
		Endif
	Endif
Endif

//???????????????????????????????
//?ermite que o usuario altere dados de transporte, entrega e ?
//?ondicao de pagamento                                       ?
//???????????????????????????????
Tk273Trans(	@cCodTransp	, @cTransp		, @cCodPagto, @cDescPagto	,;
			@cEnt		, @cBairroE		, @cCidadeE	, @cCepE		,;
			@cUfE		)


//??????????????????????
//?e nao estiver usando a entrada automatica?
//??????????????????????
If !lTk271Auto
	//???????????
	//?tualiza os objetos ?
	//???????????
	oDescPagto:Refresh()
	oCodPagto:Refresh()
	oCodTransp:Refresh()
	oTransp:Refresh()
	oEnt:Refresh()
	oCidadeE:Refresh()
	oCepE:Refresh()
	oUfE:Refresh()
	oBairroE:Refresh()
	oCob:Refresh()
	oCidadeC:Refresh()
	oCepC:Refresh()
	oUfC:Refresh()
	oBairroc:Refresh()
Endif

Return(.T.)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271MontaParcela?Autor ?Vendas Clientes?Data ?17/05/00 ??
???????????????????????????????????????
??escri??o ?onta Array com Parcelas de acordo com a condicao de        ??
??         ?agamento escolhida com data,valor e forma de pagamento     ??
???????????????????????????????????????
??intaxe   ?Tk273MontaParcela(ExpN1,	ExpC2,	ExpN3,	ExpO4,            ??
??         ?                  ExpN5, ExpO6,  ExpC7,  ExpO8             ??
??         ?                  ExpA9, ExpO10, ExpC11, ExpO12,           ??
??         ?                  ExpN13,ExpO14, ExpN15, ExpO16,           ??
??         ?                  ExpC17,ExpO18, ExpN19, ExpO20,           ??
??         ?                  ExpN21,ExpO22, ExpN23, ExpC24,           ??
??         ?                  ExpL25,ExpN26, ExpO27, ExpL28            ??
??         ?                                                           ??
???????????????????????????????????????
??arametros?ExpN1 = opcao selecionada pelo usuario                	  ??
??         ?ExpC2 = numero do atendimento                              ??
??         ?ExpN3 = valor liquido                                      ??
??         ?ExpO4 = objeto msget para valor liquido                 	  ??
??         ?ExpN5 = valor da taxa de juros                             ??
??         ?ExpO6 = objeto msget valor da taxa de juros                ??
??         ?ExpC7 = taxa de desconto                                   ??
??         ?ExpO8 = objeto msget taxa de desconto                      ??
??         ?ExpA9 = array de parcelas                                  ??
??         ?ExpO10= objeto browse de parcelas                          ??
??         ?ExpC11= cod. condicao de pagamento                         ??
??         ?ExpO12= objeto msget para condicao de pagamento            ??
??         ?ExpN13= valor da entrada                                   ??
??         ?ExpO14= objeto msget com valor de entrada                  ??
??         ?ExpN15= valor financiado                                   ??
??         ?ExpO16= objeto msget com valor financiado                  ??
??         ?ExpC17= valor do desconto                                  ??
??         ?ExpO18= objeto msget do valor do desconto                  ??
??         ?ExpN19= quantidade de parcelas                             ??
??         ?ExpO20= objeto msget com quantidade de parcelas            ??
??         ?ExpN21= prazo                                              ??
??         ?ExpO22= objeto msget prazo                                 ??
??         ?ExpN23= valor do juros                                     ??
??         ?ExpC24= controla alteracoes enquanto nao esta salvo        ??
??         ?ExpL25= flag para condicao de pagto do tipo 9.             ??
??         ?ExpN26= valor nao faturado                                 ??
??         ?ExpO27= objeto msget do valor nao faturado                 ??
??         ?ExpL34= controle de verificacao da regra de negocio        ??
??         ?ExpL35= controle de verificacao da regra de negocios       ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273MontaParcela(	nOpc		,cNumTlv	,nLiquido		,oLiquido		,;
							nTxJuros	,oTxJuros	,nTxDescon		,oTxDescon		,;
							aParcelas	,oParcelas	,cCodPagto		,oCodPagto		,;
							nEntrada	,oEntrada	,nFinanciado	,oFinanciado	,;
							cDescPagto	,oDescPagto	,nNumParcelas	,oNumParcelas	,;
							nVlrPrazo	,oVlrPrazo	,nVlJur			,cCodAnt		,;
							lTipo9		,nValNFat	,oValNFat		,lEntrada		,;
							oFis		,nSuframa	,oSuframa		,nTotal			,;
							oTotal		,lTLVReg1   ,lTLVReg2)

Local cForma1 		:= SPACE(2)													// Variavel auxiliar da forma
Local cForma2 		:= SPACE(2)             									// Variavel auxiliar da forma
Local nParcelas		:= 0														// Numero de parcelas
Local nTotalParcela	:= 0														// Total das parcelas
Local nCont			:= 0														// Contador
Local nResto 		:= 0														// diferenca da parcela (entrada) e do valor total
Local nTotParc      := 0														// variavel auxiliar
Local aVazio 		:= {}														// Array vazio
Local aAux 			:= {}														// Array auxiliar
Local dDataPar		:= CTOD("  /  /  ")											// Data da 1 parcela
Local dDataCond		:= dDataBase												// Data para desdobramento
Local lCalcula		:= .F.														// Flag para controle do recalculo das parcelas
Local nContx        := 0 														// Contador auxiliar
Local aTipo9		:= {}														// Se a condicao for do tipo 9 alimenta o array com as parcelas
Local lTMKVLDE4  	:= FindFunction("U_TMKVLDE4")								// Flag para validar a existencia do Rdmake de P.E. TMKVLDE4
Local lRet 			:= .F.														// Retorno da funcao
Local lCondBlq		:= .F.
Local cOperAnt		:= CRIAVAR("UA_OPER",.F.)									// Variavel com a OPERACAO original do atendimento em caso de alteracao.
Local dCalculo		:= M->UA_EMISSAO											// Data que sera usada no calculo da condicao de pagamento. Alteracao de uma operacao de FATURAMENTO = M->UA_EMISSAO, Orcamento = dDataBase
Local aProdDesc		:= {}														// Array com os produtos e seus descontos. Utilizado na verifica?o da regra de neg?io
Local cMensagem		:= ""														// String utilizado em exibi?o de mensagens din?icas.
Local cForma3		:= "CH"														// Forma de pagamento padr?, quando essa n? ?informada
Local cTipo9		:= Posicione("SE4",1,xFilial("SE4")+cCodPagto,"E4_TIPO")	// Retorna o tipo da condi?o de pagamento
Local lPedidoBloq	:= .F.														// Se a regra de neg?io bloquear?o pedido
Local nPProd		:= aPosicoes[1][2]											// Recebe a posi?o do campo UB_PRODUTO
Local nPItem		:= aPosicoes[20][2]											// Recebe a posi?o do campo UB_ITEM
Local nPPrven		:= aPosicoes[5][2]											// Recebe a posi?o do campo UB_VRUNIT
Local nPPrlis		:= aPosicoes[15][2]											// Recebe a posi?o do campo UB_PRCTAB
Local nPDesc		:= aPosicoes[9][2]											// Recebe a posi?o do campo UB_DESC
Local lMV_TMKFIS	:= IIf(lTk271Auto, .T., GetNewPar("MV_TMKFIS",.T.))								// (N? divulgar) Parametro que indica que a atualiza?o da MATXFIS ?feita de maneira on-line, no off-line a MATXFIS s??atualizada quando se entra na condi?o de pagamento.
Local lRecParc		:= .F.														//  Define necessidade de recalcular parcelas
Local nDescon		:= 0
Local lLimpa		:= .F.
Local nPorcParc		:= 0
Local _nValTot      := 0  //VARIAVEL ELB
Local _nValParc     := 0 // VARIAVEL ELB
Default lEntrada := .F.
Default lTLVReg1 := .F. 														// controle de validacao da regra de negocios
Default lTLVReg2 := .F. 														// controle de validacao da regra de negocios

// validação de condição de pagamento por Número de Famílias de produtos OU Estado do cliente
If !(U_MTXXPG(.F.))
	Return(.F.)
EndIf

If cTipo9 <> "9" .AND. cCodAnt <> cCodPagto
	lEntrada := .F.
	aParcelas := {}
EndIf

If lTipo9
	aTipo9 := aClone(aParcelas)
EndIf

If lTMKVLDE4
	lRet := U_TMKVLDE4(nOpc,cCodPagto,oCodPagto)
	If (ValType(lRet) <> "L")
		Return(.F.)
	ElseIf !lRet
		Return(.F.)
	Endif
	lRet := .F.
Endif

//?????????????????????????????????????
//?lag para controlar se as alteracoes do usuario enquanto o atendimento ?
//?ao foi gravado e o conteudo permanece nas variaveis de memoria	      ?
//?????????????????????????????????????
If cCodAnt <> cCodPagto
	cCodAnt   := cCodPagto
	lCalcula  := .T.
	lTLVReg1  := .F.
	lTLVReg2  := .F.
   	If !SE4->E4_TIPO == "9"
		DbSelectArea("SL4")
   		DbSetOrder(1)
   		// Valido a existencia das parcelas gravadas no SL4. Se nao existir, monta as parcelas novamente.
		If DbSeek(xFilial("SL4")+cNumTlv+"SIGATMK ")
			While (!SL4->(Eof())) .AND. (xFilial("SL4") == SL4->L4_FILIAL) .AND. ;
					   			  (SL4->L4_NUM == cNumTlv) 			.AND. ;
		  				  		  (AllTrim(SL4->L4_ORIGEM) == "SIGATMK")

		   		SL4->( RecLock("SL4", .F.) )
		   		SL4->( DbDelete() )
		   		SL4->( MsUnLock() )
		   		SL4->( DbSkip() )
			End
		EndIf
   	EndIF
	DbSelectArea("SE4")
	DbSetOrder(1)
	If DbSeek(xFilial("SE4")+cCodPagto)
		cDescPagto:= SE4->E4_DESCRI
		//???????????????????????????????????????????????????????
		//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
		//???????????????????????????????????????????????????????
		If !lTk271Auto
			oDescPagto:Refresh()
		Endif

        //Tratativa para desconsiderar o valor de desconto na parcela quando o orcamento utilizar o credito do SAC.
        If M->UA_ZCRESAC == "S"

            If (aValores[TOTAL] + aValores[02]) > SE4->E4_SUPER .AND. SE4->E4_SUPER <> 0 .AND. SuperGetMv("MV_CNDPLIM",,"1") == "1"
                If !lTk271Auto
                    Help(" ","1","LJLIMSUPER")
                Endif
                lRet	:= .F.
            ElseIf (aValores[TOTAL] + aValores[02]) < SE4->E4_INFER .AND. SE4->E4_INFER <> 0 .AND. SuperGetMv("MV_CNDPLIM",,"1") == "1"
                If !lTk271Auto
                    Help(" ","1","LJLIMINFER")
                Endif
                lRet	:= .F.
            Endif

        Else

            If aValores[TOTAL] > SE4->E4_SUPER .AND. SE4->E4_SUPER <> 0 .AND. SuperGetMv("MV_CNDPLIM",,"1") == "1"
                If !lTk271Auto
                    Help(" ","1","LJLIMSUPER")
                Endif
                lRet	:= .F.
            ElseIf aValores[TOTAL] < SE4->E4_INFER .AND. SE4->E4_INFER <> 0 .AND. SuperGetMv("MV_CNDPLIM",,"1") == "1"
                If !lTk271Auto
                    Help(" ","1","LJLIMINFER")
                Endif
                lRet	:= .F.
            Endif

        EndIf

    Endif

// Se n? houve alteracao dos itens do atendimento e as parcelas j?est? preenchidas, mantem o conteudo das PARCELAS
ElseIf aValores[BASEDUP] == (nEntrada + nFinanciado) .AND. Len(aParcelas) > 0
	If lTipo9
		lCalcula := .T.
	Else
		nVlrPrazo := nEntrada + nFinanciado
		//??????????????????????
		//?e nao estiver usando a entrada automatica?
		//??????????????????????
		If !lTk271Auto
			oVlrPrazo:Refresh()
		Endif
		lRet := .T.
		lRecParc := .T. // nao recalcula a parcela
	Endif
Else
	// Se houve alteracao dos itens do atendimento REFAZ AS PARCELAS
	lCalcula := .T.
	lLimpa	 := .T.
Endif

If !lRecParc
	Do case
		case nOpc == 3 // Incluir
			//???????????????????????????????????????????
			//?omo e uma inclusao o valor de calculo sera baseado no valor da mercadoria         ?
			//? a parcelas serao calculadas de acordo com a condicao escolhida (com ou sem juros)?
			//???????????????????????????????????????????
			nLiquido 	:= aValores[BASEDUP] - aValores[ACRESCIMO]
			nSuframa	:= aValores[SUFRAMA]
			nTotal		:= aValores[TOTAL]
			If lLimpa
				aParcelas := aClone(aVazio)
			Endif
			nEntrada 	:= 0
			nFinanciado	:= 0
			nTxJuros 	:= 0
			nTxDescon	:= 0
			nVlrPrazo 	:= 0
			nVlJur 		:= 0

			//????????????????????????????
			//?ego as informacoes da Condicao de Pagto Escolhida F3?
			//????????????????????????????
			DbSelectArea("SE4")
			DbSetOrder(1)
			If !DbSeek(xFilial("SE4")+cCodPagto)
				//??????????????????????
				//?e nao estiver usando a entrada automatica?
				//??????????????????????
				If !lTk271Auto
					oParcelas:SetArray(aParcelas)
					oParcelas:Refresh()
					Help(" ",1,"FALTA_PGTO")
				Endif
				Return(lRet)
			Endif

			//?????????????????????????????????????
			//?erifica a TABELA de precos inforamada existe                           ?
			//?????????????????????????????????????
			DbSelectArea("DA0")
			DbSetOrder(1)
			If !Empty(M->UA_TABELA)
				If !DbSeek(xFilial("DA0")+M->UA_TABELA)
					//???????????????????????????????????????????????????????
					//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
					//???????????????????????????????????????????????????????
					If !lTk271Auto
						Help(" ",1,"OMSTABPRC2")
					Endif
					Return(lRet)
				Endif
			Endif

			DbSelectArea("SE4")
			//??????????????????????????????????????????
			//?erifica se a condicao de pagamento escolhida esta de acordo com a tabela de preco?
			//??????????????????????????????????????????
			If !MaVldTabPrc(M->UA_TABELA,cCodPagto)
				Return(lRet)
			Endif

			cDescPagto:= SE4->E4_DESCRI
			//??????????????????????
			//?e nao estiver usando a entrada automatica?
			//??????????????????????
			If !lTk271Auto
				oDescPagto:Refresh()
			Endif

			//??????????????????????????????????????
			//?ega a porcentagem de juros da condicao de pagamento ou a de desc. finan.?
			//??????????????????????????????????????
			If !Empty(SE4->E4_ACRSFIN)
				nTxJuros := SE4->E4_ACRSFIN
				//??????????????????????
				//?e nao estiver usando a entrada automatica?
				//??????????????????????
				If !lTk271Auto
					oTxJuros:Refresh()
				Endif
			ElseIf !Empty(SE4->E4_DESCFIN)
				nTxDescon:= SE4->E4_DESCFIN
				//??????????????????????
				//?e nao estiver usando a entrada automatica?
				//??????????????????????
				If !lTk271Auto
					oTxDescon:Refresh()
				Endif
			Endif

			//??????????????????????????????????????
			//?ega a Forma de Pagamento										        ?
			//??????????????????????????????????????
			If Empty(SE4->E4_FORMA)
				cForma1 := "CH"
			Else
				cForma1 := SE4->E4_FORMA
			EndIf
			If Empty(SE4->E4_FORMA)
				cForma2 := cForma1
			Elseif Empty(SubStr(SE4->E4_FORMA,1,TAMSX3("E4_FORMA")[1]))
				cForma2 := cForma1
			Else
				cForma2 := SubStr(SE4->E4_FORMA,1,TAMSX3("E4_FORMA")[1])
			Endif

			//???????????????????????????????????????????
			//?alculo o valor do juro para atualizar o ACRESCIMO e o valor TOTAL do atendimento  ?
			//???????????????????????????????????????????
			nVlJur := Tk273RecCpg( cCodPagto )

			If !lMV_TMKFIS
				Tk273AtuNFs()

				aValores[MERCADORIA] := MaFisRet(, "NF_VALMERC")
				aValores[SUFRAMA] := MaFisRet(, "NF_DESCZF")
				aValores[TOTAL] := MaFisRet(, "NF_TOTAL")
				aValores[BASEDUP] := MaFisRet(, "NF_BASEDUP")
				If !lTk271Auto
					oFis:Refresh()
				EndIf
			EndIf

			// Calcula novamente o nLiquido para subtrair o valor de acrescimo que foi calculado
			nLiquido := aValores[BASEDUP] - aValores[ACRESCIMO]
			nSuframa := aValores[SUFRAMA]
			nTotal	 := aValores[TOTAL]

			//??????????????????????????????????????
			//? tipo 9 e carregado em uma funcao especifica                            ?
			//??????????????????????????????????????
			If cTipo9 == "9"
				//??????????????????????
				//?e nao estiver usando a entrada automatica?
				//??????????????????????
				If !lTk271Auto
					If Empty(aParcelas)
						If nLiquido > 0
							aParcelas := TK273TipoNove(	nOpc			,nLiquido	,nVlJur	,cForma1,;
													SE4->E4_COND	,cNumTlv	,aTipo9	,lTipo9,;
													lCalcula)
						Else
							AADD(aParcelas,{	dDataBase	,;	// 1 - Data
											0		,;	// 2 - Valor
											cForma1		,;	// 3 - Forma de Pagamento
											Space(80)	,;	// 4 - Complemento
											0			,;	// 5 - Valor R$ ou %
											Space(01)	})	// 6 - ID Cartao (para visualiz. sintetica)
						EndIf
						nParcelas := Len(aParcelas)
						lTipo9 	  := .T.
					EndIf
				Else
					//?????????????????????????
					//?enda tipo 9 nao funciona em entrada automatica?
					//?????????????????????????
				   Return(lRet)
				Endif
			Else
				//??????????????????????????????????????
				//?onta as parcelas com a funcao padrao CONDICAO (valor de compra + Juros 	?
				//??????????????????????????????????????
				aAux := {}
				aAux := Condicao(	(nLiquido + nVlJur)		, cCodPagto	, MaFisRet(,"NF_VALIPI")	, M->UA_EMISSAO	,;
									MaFisRet(,"NF_VALSOL")	, Nil		, Nil						, nVlJur		)

				nParcelas := Len(aAux)

				If nCont == 1
					cForma3 := cForma1
				Else
					cForma3 := cForma2
				EndIf
				If Empty(cForma3)
					cForma3 := "CH"
				EndIf

                //AQUI TEM INICIO A CUSTOMIZAÇÃO PARA PARCELAS ELB
                If aValores[4] > 0   //aValores4 é igual ao frete

                 _nValTot := AVALORES[8] - aValores[4]


                    For nCont := 1 To nParcelas

                       _nValParc:= _nValTot/nParcelas

                        IF nCont == 1
                            _nValParc:= _nValParc+ aValores[4]
                        Endif

                        Aadd(aParcelas,{	aAux[nCont][1]	, _nValParc	, cForma3	, Space(80)	,;
                                            0				, space(1)			})
                    Next nCont
                else

                     For nCont := 1 To nParcelas
                        Aadd(aParcelas,{	aAux[nCont][1]	, aAux[nCont][2]	, cForma3	, Space(80)	,;
                                            0				, space(1)			})
                    Next nCont

                ENDIF
                //FINAL DA CUSTOMIZAÇÃO ELB PARA COLOCAR O FRETE NA PRIMEIRA PARCELA
            Endif

			//???????????????????????????????
			//?tualiza a tela, pois pode acontecer de algum campo n? ser?
			//?lterado e permanecer visualmente desatualizado.           ?
			//???????????????????????????????
			If !lTk271Auto
				oLiquido:Refresh()
				oEntrada:Refresh()
				oFinanciado:Refresh()
				oTxJuros:Refresh()
				oTxDescon:Refresh()
				oVlrPrazo:Refresh()
				oSuframa:Refresh()
				oTotal:Refresh()
			EndIf

		case nOpc == 4 .OR. nOpc == 2	// Alterar ou Visualizar
			If !Empty(M->UA_EMISNF) .And. M->UA_STATUS = 'NF.'
				dDataCond := M->UA_EMISNF
			EndIf
			//??????????????????????
			//?e foi determinado o calculo das parcelas ?
			//??????????????????????
			If lCalcula

				//?????????????????
				//?e as parcelas estiverem vazias?
				//?????????????????
				If Len(aParcelas) == 0

					//?????????????????????????????????????????
					//?Monta as parcelas de acordo com a condicao de pagamento gravada no atendimento ?
					//?????????????????????????????????????????
					aParcelas   := aClone(aVazio)
					nTotParc  := 0
					DbSelectArea("SL4")
					DbSetOrder(1)
					// Valido a existencia das parcelas gravadas no SL4.
					// Se nao existir ou se a data de emiss? for diferente da database, monta as parcelas novamente.
					If DbSeek(xFilial("SL4")+cNumTlv + "SIGATMK") .And. (dDataCond == dCalculo)
						While (!SL4->(Eof())) .AND. (xFilial("SL4") == SL4->L4_FILIAL) .AND. ;
											 (SL4->L4_NUM == cNumTlv) 			.AND. ;
						  					 (AllTrim(SL4->L4_ORIGEM) == "SIGATMK")
	                        If  cTipo9 == "9"
	                        	nPorcParc := (L4_VALOR/UA_VLRLIQ) * 100
		                    Else
		                    	nPorcParc :=  VAL(L4_COMP)
		                    EndIf

							AADD(aParcelas,{L4_DATA			,;	// 1 - Data
											L4_VALOR		,;	// 2 - Valor
											LEFT(L4_FORMA,TAMSX3("L4_FORMA")[1]),;	// 3 - Forma de pagamento
											L4_OBS			,;	// 4 - Complemento
											nPorcParc   	,;	// 5 - R$ ou %
											IIf(lVisuSint,L4_FORMAID,space(1)) })	// 6 - ID Cartao


							nTotParc += SL4->L4_VALOR
							SL4->(DbSkip())
						End
					Else
						//??????????????????????????????????????
						//?onta as parcelas com a funcao padrao CONDICAO (valor de compra + Juros 	?
						//??????????????????????????????????????
						nVlJur := Tk273RecCpg( cCodPagto )

						If !lMV_TMKFIS
							Tk273AtuNFs()

							aValores[MERCADORIA] := MaFisRet(, "NF_VALMERC")
							aValores[SUFRAMA] := MaFisRet(, "NF_DESCZF")
							aValores[TOTAL] := MaFisRet(, "NF_TOTAL")
							aValores[BASEDUP] := MaFisRet(, "NF_BASEDUP")
							If !lTk271Auto
	                        	oFis:Refresh()
							EndIf
						EndIf

						aAux := {}
						aAux := Condicao(	(nLiquido + nVlJur)		, cCodPagto	, MaFisRet(,"NF_VALIPI")	, dDataCond	,;
											MaFisRet(,"NF_VALSOL")	, Nil		, Nil						, nVlJur	)

						nParcelas := Len(aAux)

						//??????????????????????????????????????
						//?ega a Forma de Pagamento										        ?
						//??????????????????????????????????????
						DbSelectArea("SE4")
						DbSetOrder(1)
						If DbSeek(xFilial("SE4")+cCodPagto)
							If Empty(SE4->E4_FORMA)
								cForma1  := "CH"
							Else
								cForma1  := SE4->E4_FORMA
							EndIf
							If Empty(SE4->E4_FORMA)
								cForma2 := cForma1
							Elseif Empty(SubStr(SE4->E4_FORMA,1,TAMSX3("E4_FORMA")[1]))
								cForma2 := cForma1
							Else
								cForma2 := SubStr(SE4->E4_FORMA,1,TAMSX3("E4_FORMA")[1])
							Endif
						Endif

						For nCont := 1 To nParcelas
							Aadd(aParcelas,	{aAux[nCont][1]	, aAux[nCont][2]	, Iif(nCont==1,cForma1,cForma2)	, Space(80)	,;
											0				, space(1)			})
							nTotParc +=aAux[nCont][2]
						Next nCont
			        Endif

					//???????????????????????????????????????????????????
					//?e total gravado anteriormente for <> do valor atual do atendimento - calcula novamente as parcelas?
					//???????????????????????????????????????????????????
					If nTotParc <> aValores[BASEDUP]
						lCalcula := .T.
					Else
						lCalcula := .F.
					Endif

					//???????????????????????????????????????????????????
					//?erifica se a data das parcelas serao RECALCULADAS ou NAO                                          ?
					//???????????????????????????????????????????????????
					DbSelectArea("SUA")
					DbSetOrder(1)
					If DbSeek(xFilial("SUA")+cNumTlv)
						cOperAnt := SUA->UA_OPER
						//??????????????????????????????????
						//?e a operacao anterior era de ATENDIMENTO/ORCAMENTO              ?
						//??????????????????????????????????
						If ( VAL(cOperAnt) == ATENDIMENTO .OR. VAL(cOperAnt) == ORCAMENTO )
							//???????????????????????????????????????????????
							//? agora mudou para FATURAMENTO e a data de alteracao e nova - RECALCULA A DATA DAS PARCELAS?
							//???????????????????????????????????????????????
							If (VAL(M->UA_OPER) == FATURAMENTO) .AND. (M->UA_EMISSAO <> dDataBase)
								lCalcula := .T.
								dCalculo := dDataBase
							Endif
						Endif
	            	Endif
				Else
					lCalcula := .T.
				Endif

			Else

				//???????????????????????????????
				//?oma o valor das parcelas que foram gravadas no atendimento ?
				//???????????????????????????????
				For nCont :=1 To Len(aParcelas)
					nTotParc += aParcelas[nCont][2]
				Next nCont
			Endif

			nParcelas := Len(aParcelas)

			//?????????????????????
			//?etermina a data do primeiro pagamento ?
			//?????????????????????
			If nParcelas > 0
				dDataPar := aParcelas[1][1]
			Endif

			//???????????????????????????????????????
			//?e mudou o valor liquido do pedido consultado refaz as parcelas da condicao ?
			//???????????????????????????????????????
			If nToTParc <> (nEntrada + nFinanciado) .OR. lCalcula

				nLiquido 	:= aValores[BASEDUP] - aValores[ACRESCIMO]
				nSuframa	:= aValores[SUFRAMA]
				nTotal		:= aValores[TOTAL]
				aParcelas   := aClone(aVazio)
				nNumParcelas:= 0
				nParcelas	:= 0
				nEntrada 	:= 0
				nFinanciado	:= 0
				nTxJuros 	:= 0
				nTxDescon	:= 0
				nVlrPrazo 	:= 0
				nVlJur 		:= 0

				//????????????????????????????
				//?ego as informa?oes da Condi?ao de Pagto Escolhida F3?
				//????????????????????????????
				DbSelectArea("SE4")
				DbSetOrder(1)
				If !DbSeek(xFilial("SE4")+cCodPagto)
					//??????????????????????
					//?e nao estiver usando a entrada automatica?
					//??????????????????????
					If !lTk271Auto
						oParcelas:SetArray(aParcelas)
						oParcelas:Refresh()
						Help(" ",1,"FALTA_PGTO")
					Endif
					Return(lRet)
				Endif

				cDescPagto:= SE4->E4_DESCRI
				//??????????????????????
				//?e nao estiver usando a entrada automatica?
				//??????????????????????
				If !lTk271Auto
					oDescPagto:Refresh()
				Endif

				//??????????????????????????????????????
				//?ega a porcentagem de juros da condicao de pagamento ou a de desc. finan.?
				//??????????????????????????????????????
				If !Empty(SE4->E4_ACRSFIN)
					nTxJuros := SE4->E4_ACRSFIN
					//??????????????????????
					//?e nao estiver usando a entrada automatica?
					//??????????????????????
					If !lTk271Auto
						oTxJuros:Refresh()
					Endif
				ElseIf !Empty(SE4->E4_DESCFIN)
					nTxDescon:= SE4->E4_DESCFIN
					//??????????????????????
					//?e nao estiver usando a entrada automatica?
					//??????????????????????
					If !lTk271Auto
						oTxDescon:Refresh()
					Endif
				Endif

				//??????????????????????????????????????
				//?ega a Forma de Pagamento										        ?
				//??????????????????????????????????????
				If Empty(SE4->E4_FORMA)
					cForma1  := "CH"
				Else
					cForma	:= SE4->E4_FORMA
					cForma1	:= SE4->E4_FORMA
				EndIF
				If Empty(SE4->E4_FORMA)
					cForma2 := cForma1
				Elseif Empty(SubStr(SE4->E4_FORMA,1,TAMSX3("E4_FORMA")[1]))
					cForma2 := cForma1
				Else
					cForma2 := SubStr(SE4->E4_FORMA,1,TAMSX3("E4_FORMA")[1])
				Endif

				//????????????????????????????
				//?alculo o valor do juro sobre o valor da compra      ?
				//????????????????????????????
				nVlJur := Tk273RecCpg( cCodPagto )

				If !lMV_TMKFIS
					Tk273AtuNFs()

					aValores[MERCADORIA] := MaFisRet(, "NF_VALMERC")
					aValores[SUFRAMA] := MaFisRet(, "NF_DESCZF")
					aValores[TOTAL] := MaFisRet(, "NF_TOTAL")
					aValores[BASEDUP] := MaFisRet(, "NF_BASEDUP")
					If !lTk271Auto
						oFis:Refresh()
					EndIf
				EndIf

				//Calcula novamente o nLiquido para subtrair o valor de acrescimo que foi calculado
				nLiquido := aValores[BASEDUP] - aValores[ACRESCIMO]

				//??????????????????????????????????????
				//? tipo 9 e carregado em uma funcao especifica                            ?
				//??????????????????????????????????????
				If SE4->E4_TIPO == "9" .AND. nOpc <> 2
					//??????????????????????
					//?e nao estiver usando a entrada automatica?
					//??????????????????????
					If !lTk271Auto
						If nLiquido > 0
							aParcelas := TK273TipoNove(	nOpc		,nLiquido	,nVlJur	,cForma1,;
														SE4->E4_COND,cNumTlv	,aTipo9	,lTipo9,;
														lCalcula)
						Else
							AADD(aParcelas,{	dDataBase	,;	// 1 - Data
											0		,;	// 2 - Valor
											cForma1		,;	// 3 - Forma de Pagamento
											Space(80)	,;	// 4 - Complemento
											0			,;	// 5 - Valor R$ ou %
											Space(01)	})	// 6 - ID Cartao (para visualiz. sintetica)
						EndIf
						nParcelas := Len(aParcelas)
						lTipo9 	  := .T.
					Else
						//?????????????????????????
						//?enda tipo 9 nao funciona em entrada automatica?
						//?????????????????????????
						Return(lRet)
					Endif
				Else
					//????????????????????????????????????????????????????
					//?e o array aParcelas esta vazio quer dizer que nao foi escolhido uma condicao anteriomente - ORCAMENTO?
					//????????????????????????????????????????????????????
					If nParcelas == 0

						If (VAL(M->UA_OPER) <> ORCAMENTO)
							dDataCond := dCalculo
						EndIf

						aAux := {}
						aAux := Condicao(	(nLiquido + nVlJur)		, cCodPagto	, MaFisRet(,"NF_VALIPI")	, dDataCond	,;
											MaFisRet(,"NF_VALSOL")	, Nil		, Nil						, nVlJur	)
						nParcelas := Len(aAux)

						If nCont == 1
							cForma3 := cForma1
						Else
							cForma3 := cForma2
						EndIf
						If Empty(cForma3)
							cForma3 := "CH"
						EndIf

						For nCont := 1 To nParcelas
							Aadd(aParcelas	, {	aAux[nCont][1]	, aAux[nCont][2]	, cForma3	, Space(80)	,;
												0				, space(1)			})
						Next nCont
					Endif

				Endif
			Endif
	Endcase
Else
	If nParcelas <= 0
		nParcelas := Len(aParcelas)
	EndIf
Endif

If Len(aParcelas) > 0

	If !lTLVReg1
		//?????????????????????????????
		//?onta a array para verifica?o dos descontos atrav? da?
		//?un?o FtRegraNeg                                      ?
		//?????????????????????????????
		//????????????????????????????????????????
		//?      Estrutura do array aProdDesc                                          ?
		//?      [1] - Codigo do Produto                                               ?
		//?      [2] - Item do Pedido de Venda                                         ?
		//?      [3] - Preco de Venda                                                  ?
		//?      [4] - Preco de Lista                                                  ?
		//?      [5] - % do Desconto Concedido no item do pedido                       ?
		//?      [6] - % do Desconto Permitido pela regra (FtRegraNeg)                 ?
		//?      [7] - Indica se sera necessario verificar o saldo de verba            ?
		//?                            01 - Bloqueio de regra de negocio               ?
		//?                            02 - Bloqueio para verificacao de verba         ?
		//?      [8] - Valor a ser abatido da verba caso seja aprovada (FtVerbaVen)    ?
		//?      [9] - Flag que indica se o item sera analisado nas regras             ?
		//????????????????????????????????????????
		For nContx := 1 To Len(aCols)
			If !GdDeleted(nContx)
				If aCols[nContx][nPDesc] == 0 .And. aCols[nContx][nPPrven] < aCols[nContx][nPPrlis]
					nDescon := (100 - (aCols[nContx][nPPrven] / aCols[nContx][nPPrlis]) * 100 )
				Else
					nDescon := aCols[nContx][nPDesc]
				EndIf
				Aadd(aProdDesc,{	aCols[nContx][nPProd]	, aCols[nContx][nPItem]	, aCols[nContx][nPPrven]	, aCols[nContx][nPPrlis]	,;
									nDescon	, 0					, ""				, 0					,;
									.T.					})
			EndIf
		Next nContx

		//??????????????????????????????????????????
		//?erifica se a regra de negocio cadastrada e valida com a tabela de preco escolhida?
		//??????????????????????????????????????????
		For nContx := 1 To Len(aParcelas)
		  	If !FtRegraNeg(	M->UA_CLIENTE			, M->UA_LOJA	, M->UA_TABELA	, cCodPagto	,;
							aParcelas[nContx][3]	, @aProdDesc	, .F., nil , .T.			)
				lPedidoBloq := .T.
				lTLVReg2 := .T.
			Endif
		Next nContx

		//?????????????????????????????
		//?xibe uma mensag? din?ica com os produtos que est?   ?
		//?om o desconto acima do permitido pela regra do neg?io.?
		//?????????????????????????????
		For nCont:=1 To Len(aProdDesc)
			If aProdDesc[nCont][7] == "02"
				lTLVReg1 := .T.// regra de negocios bloqueada por desconto.
				If nCont == 1 .OR. Empty(cMensagem)
					cMensagem += 'Os seguintes produtos ocasionarao o bloqueio do pedido devido a regra de negocios referente ao desconto:' + Chr(13) + Chr(10) // "Os seguintes produtos ocasionar? o bloqueio do pedido devido ?regra de neg?ios referente ao desconto:"
				Endif
				cMensagem += AllTrim(aCols[nCont][3]) + Chr(13) + Chr(10) + 'Atual' + Transform(aProdDesc[nCont][5],aHeader[8][3]) + ' / Minimo Permitido' + Transform(aProdDesc[nCont][6],aHeader[8][3]) + Chr(13) + Chr(10) // " - atual: " // " m?imo permitido: "
			Endif
		    If aProdDesc[nCont][7] == "01"
				lTLVReg1 := .T.// regra de negocios bloqueada por produto n? consta na regra.
		    Endif
		Next nCont

		If Len(cMensagem) > 0
			MsgStop(cMensagem, 'Atencao') // "Aten?o"
			lCondBlq := .T.
		ElseIf lPedidoBloq
			MsgInfo('Conforme a configura?o das condi?es comerciais determinadas pela regra de neg?io da empresa, este pedido de venda ser?gerado como bloqueado.','Atencao') //"Conforme a configura?o das condi?es comerciais determinadas pela regra de neg?io da empresa, este pedido de venda ser?gerado como bloqueado." ## "Aten?o"
		EndIf
	EndIf
 If !lEntrada
	//?????????????
	//?ega o total da parcela.?
	//?????????????
	For nCont:=1 To nParcelas
		nTotalParcela += Round(aParcelas[nCont][2],2)
	Next nCont

	//??????????????????????????????
	//?Carrega a Entrada										?
	//??????????????????????????????
	nEntrada := 0
	For nCont := 1 To nParcelas
		If aParcelas[nCont][1] == dDataBase
			nEntrada += aParcelas[nCont][2]
		EndIf
	Next nCont

	If !lTk271Auto
		oEntrada:Refresh()
	Endif

	//??????????????????????????????
	//?Carrega o valor a ser financiado						?
	//??????????????????????????????
	nFinanciado := 0
	For nCont := 1 TO nParcelas
		If aParcelas[nCont][1] > dDataBase
			nFinanciado += Round(aParcelas[nCont][2],2)
		Endif
	Next nCont

	//??????????????????????????????
	//?Ajuste da ultima parcela (arredondamento)				?
	//??????????????????????????????
	nResto := aValores[BASEDUP] - nTotalParcela
	If (nResto <> 0) .And. Len(aParcelas) >= (nCont-1)
		aParcelas[nCont-1][2] += nResto

		//????????????????????????????
		//?Incrementa no valor financiado a diferen?a       	?
		//????????????????????????????
		If nFinanciado > 0
			nFinanciado += Round(nResto,2)
		Endif
	Endif

	If !lTk271Auto
		oFinanciado:Refresh()
	EndIf
 EndIf
Endif

//??????????????????????
//?e nao estiver usando a entrada automatica?
//??????????????????????
If !lTk271Auto

	oParcelas:SetArray(aParcelas)
	oParcelas:bLine := {||{	DTOC(aParcelas[oParcelas:nAt,1]),;  //Visualizacao
							xPadR(Transform(aParcelas[oParcelas:nAt,2],"@E 999,999,999.99"),50) ,;
							aParcelas[oParcelas:nAt,3]}}

	oParcelas:Refresh()

	nNumParcelas:= nParcelas
	oNumParcelas:Refresh()

	//???????????????????????
	//?Atualiza o array de parcelas sintetizadas ?
	//???????????????????????
	If 	lVisuSint 				.AND.;
		Type("oPgtosSint")=="O" .AND.;
		lUsaTef 				.AND.;
		cTipTef == TEF_CLISITEF

		aPgtosSint := Tk273MontPgt(aParcelas)
		oPgtosSint:SetArray( aPgtosSint )
		oPgtosSint:Refresh()
	Endif

	nVlrPrazo := nEntrada + nFinanciado
	oVlrPrazo:Refresh()
	oSuframa:Refresh()
	oTotal:Refresh()
Else
	nNumParcelas := nParcelas
	nVlrPrazo := nEntrada + nFinanciado
Endif

	If lCondBlq
		lRet := .F.
	Else
		lRet := .T.
	EndIf
	lTipo9	:= .F.

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271Detalhe ?utor ?Vendas Clientes       ?ata ?8/01/02 ??
???????????????????????????????????????
??escri??o ?ela para preenchimento com os detalhes de cada tipo de     ??
??         ?arcela CHEQUE, CARTAO e FINANCIAMENTO                      ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273Detalhe(aParcelas	,oParcelas	,aItens		,lHabilita,;
							 nLiquido	,nEntrada	,oEntrada	,nFinanciado,;
							 oFinanciado,cCodPagto	,lSigaCRD   ,lTLVReg2)

Local cComplemento 	:= SPACE(80)        				// Obervacao do SL4
Local nPos 			:= 0								// Posicao no APARCELAS
Local aAux 			:= {}                               // Variavel auxiliar
Local nCont			:= 0                                // Contador
Local aMatriz 		:= {}                               // Array com as formas de pagamento
Local aChave  		:= {}								// Array com as formas de pagamento
Local cComboForma 	:= ""								// Combobox para escolhar a forma de pagamento - tabela 24
Local oComboForma										// Objeto COMBO
Local dDtParcela  	:= CTOD("  /  /  ")					// Data de vencimento da parcela - VISUAL
Local oDtParcela										// Objeto GET
Local nVlrParcela 	:= 0								// Valor da parcela - VISUAL
Local oVlrParcela                                       // Objeto GET
Local cTipo			:= ""								// Tipo da forma de pagamento
Local dDataAnt 		:= CTOD("  /  /  ")					// Data anterior
Local nValAnt  		:= 0								// Valor anterior
Local cComboAnt		:= ""                               // Conteudo do combo anterior
Local oDetailDlg										// Tela
Local lOk			:= (SuperGetMv("MV_TMKLOJ") == "I")//Flag que vai controlar a alteracao da data e do valor da parcela
														//SOMENTE QUANDO HOUVER INTEGRACAO COM SIGALOJA
Local lRet			:= .F.								// Retorno da funcao
//Local cForma		:= ""								// Forma Pagto
Local cFormaId		:= IIf(lVisuSint,Space(TamSX3("L4_FORMAID")[1]),Space(01))	// ID do cartao
Local cFormaIdAnt 	:= cFormaId							// ID anterior do cartao
Local nLinha		:= 0                            	// Linha selecionada no browse
Local nParc			:= 1								// Nr. parcelas
Local oParc 											// Objeto GET nr. parcelas
Local oCart 											// Objeto GET ID do cartao
Local oCheckPag 										// Objeto Checkbox
Local lCheckPag		:= .F.								// indica se utiliza nas prox. parcelas
//Local cSx1Hlp		:=""								// Help do objeto selecionado
Local lConfirma		:= .F.								// Indica se confirmou a operacao digitada
Local nX 			:= 1								// variav. auxiliar em lacos for...next
Local lTefMult		:= SuperGetMV("MV_TEFMULT")			// Parametro do SX6 que indica se o sistema vai o TEF multiplas transacoes
//Local nResto 		:= 0								// Restante das parcelas
Local lAltValor		:= .F.								// Indica se podera alterar o valor da parcela

Default lTLVReg2    := .F. 								// controle de validacao da regra de negocios

//???????????????????????????
//?impo os dados do complemento da parcela selecionada?
//???????????????????????????
cComplemento := SPACE(80)

If Len(aParcelas) == 0 .OR. Empty(aParcelas[1][1])
	aParcelas := {}
	aParcelas :={{CTOD("  /  /  "),0,SPACE(15),SPACE(80)}}
	//???????????????????????????????????????????????????????
	//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
	//???????????????????????????????????????????????????????
	If !lTk271Auto
		oParcelas:Refresh()
    Endif
	Return(lRet)
Endif

//????????????????????
//?Pega a linha da parcela selecionada ?
//????????????????????
If lVisuSint .AND. Type("oPgtosAna")=="O"
	//Visualizacao sintetica
	nLinha := oPgtosAna:nAt
Else
	//Visualizacao normal
	nLinha := oParcelas:nAt
Endif

//?????????????????????????????????????
//?Pega o ID do cartao quando esta habilitado o TEF com mult. transacoes ?
//?????????????????????????????????????
If	lUsaTef 	.AND.;
	lTefMult 	.AND.;
	lVisuSint

	cFormaID 	:= aParcelas[nLinha][6]
	cFormaIdAnt := cFormaID

	//??????????????????????????????????
	//?Mult. transacoes TEF: permitira alterar o valor para cada cartao ?
	//??????????????????????????????????
	lAltValor	:= .T.
Endif

dDtParcela 	:= aParcelas[nLinha,1]		//Data
nVlrParcela	:= aParcelas[nLinha,2]		//Valor da parcela

For nCont := 1 To Len(aItens)
	AAdd(aMatriz,aItens[nCont][1])
	AAdd(aChave ,aItens[nCont][2])
Next nCont

//???????????????????????????????????????????
//?esquisa no ARRAY de dados complementares da parcela qual foi a parcela selecionada?
//???????????????????????????????????????????
nPos := Ascan(aItens,{|aAux|AllTrim(aAux[2]) == AllTrim(aParcelas[nLinha,3])})

//???????????????????????????????????????????
//?ratamento para proteger o codigo caso os dados da base estejam inconsistentes     ?
//???????????????????????????????????????????
If  nPos < 1
	Help(" ",1,"TK273TAB24" )
	Return(lRet)
Endif

cComboForma	:= aItens[nPos,1]
cTipo	   	:= aItens[nPos,2]

dDataAnt  	:= aParcelas[nLinha,1]
nValAnt   	:= aParcelas[nLinha,2]
cComboAnt 	:= aParcelas[nLinha,3]

DEFINE MSDIALOG oDetailDlg FROM 10,20 TO 235,300 TITLE 'Forma de Pagamento Parcial' PIXEL STYLE DS_MODALFRAME  //"Forma de Pagamento da Parcela"

	@ 05,10 SAY 'Data' SIZE 30,8 PIXEL OF oDetailDlg  //"Data"

	@ 05,37 MSGET oDtParcela VAR dDtParcela SIZE 50,8 PIXEL OF oDetailDlg PICTURE "99/99/99" ;
			WHEN IIf(cTipTef <> TEF_CLISITEF, lOk, .F.) VALID Tk273ValData(dDataAnt	,@dDtParcela	,oDtParcela	,aParcelas,;
																			oParcelas	,aItens			,cComboForma)

	@ 20,10 SAY 'Valor' SIZE 30,8 PIXEL OF oDetailDlg //"Valor"
	@ 20,37 MSGET oVlrParcela VAR nVlrParcela SIZE 70,8 PIXEL OF oDetailDlg PICTURE "@E 9999999.99" ;
			WHEN IIf(cTipTef == TEF_CLISITEF .AND. lTefMult, lAltValor, lOk) RIGHT

	@ 35,10 SAY 'Forma' SIZE 50,8 PIXEL OF oDetailDlg //"Forma"
	@ 35,37 MSCOMBOBOX oComboForma VAR cComboForma ITEMS aMatriz SIZE 100,50 OF oDetailDlg PIXEL ;
			VALID TK273Data(cComboForma,aParcelas,aItens,dDtParcela);
			ON CHANGE (cTipo := aChave[oComboForma:nAt]) ;
			WHEN lHabilita .AND. (If(nLinha == 0 .OR. (lVisuSint .AND. cTipo$_FORMATEF) ,.F.,.T.))

	//??????????????????????????
	//?Objetos para tratamento de mult. transacoes TEF ?
	//??????????????????????????
   If lUsaTef 	.AND.;
   	  lTefMult	.AND.;
   	  lVisuSint .AND.;
   	  cTipTef == TEF_CLISITEF

	   @ 50,10 Say 'ID Cartao' SIZE 50,8 PIXEL OF oDetailDlg 	//"ID Cart?"
  	   @ 50,37 MSGET oCart VAR cFormaId RIGHT SIZE 15,08 OF oDetailDlg PIXEL PICTURE PesqPict("SL4","L4_FORMAID") ;
  		   	   WHEN  TK273WhenID(nLinha,cTipo,@cFormaId,aItens) VALID TK273ValidID(cTipo,@cFormaId,aItens)
    			oCart:cSx1Hlp:="L4_FORMAID"
   Endif

   If lVisuSint .AND. (nLinha == 0 .AND. cTipo $ _FORMATEF )
	   @ 65,10 Say 'Parcelas' SIZE 10,1 		//"Parcelas"
  	   @ 65,37 MSGET oParc VAR nParc	RIGHT SIZE 15,08 PICTURE "99" VALID(If (nParc < 1 ,(MsgStop('Valor nao permitido'), .F.),.T.)) // Valor nao permitido para esse campo
 	  	            oParc:cSx1Hlp:=""
   Endif

   If nLinha > 0 .AND. nLinha < Len(aParcelas) .AND. !IsMoney(cTipo)
	  @ 80,10 CHECKBOX oCheckPag VAR lCheckPag PROMPT 'Utiliza nas proximas parcelas' SIZE 90,8 OF oDetailDlg //"Utiliza nas pr?imas parcelas"
   	  	            oCheckPag:cSx1Hlp:=""
   Endif

	DEFINE SBUTTON FROM 95,070 TYPE 1 ACTION (Tk273Compl(@cComboForma	,@cTipo		,@aParcelas	,@oParcelas,;
														 aItens			,lHabilita	,cCodPagto	,lSigaCRD  ,@lTLVReg2,lCheckPag),;
														lConfirma:=.T., oDetailDlg:End()) ENABLE OF oDetailDlg

	DEFINE SBUTTON FROM 95,105 TYPE 2 ACTION (lConfirma:=.F., oDetailDlg:End()) ENABLE OF oDetailDlg

	// Desabilita a tecla ESC
    oDetailDlg:LESCCLOSE := .F.

ACTIVATE MSDIALOG oDetailDlg CENTER

If lConfirma
	If nVlrParcela > 0
		//????????????????
		//?Atualiza os dados da parcela ?
		//????????????????
		aParcelas[nLinha][1] := dDtParcela
		If nLinha < Len(aParcelas)
			aParcelas[nLinha][2] := nVlrParcela
		Else
			If nValAnt <> nVlrParcela
				MsgAlert('O Valor da ultima parcela nao pode ser alterado', 'Atencao') //"O valor da ?tima parcela n? poder?ser alterado"
			EndIf
		EndIf
		aParcelas[nLinha][3] := cTipo
		aParcelas[nLinha][6] := cFormaID

		//?????????????????????
		//?Recalcula o valor das demais parcelas ?
		//?????????????????????
		If nValAnt <> nVlrParcela
			Tk273ReFill( nLinha, nLiquido, aParcelas )
		EndIf

		If lCheckPag

			For nX := nLinha+1 To Len(aParcelas)
				//S?alterar as pr?imas parcelas iguais a origin?ia devido ao controle de datas
				If !IsMoney(cComboAnt) .AND. AllTrim(aParcelas[nX][3]) == AllTrim(cComboAnt) ;
					.AND. AllTrim(aParcelas[nX][6]) == AllTrim(cFormaIdAnt)

					aParcelas[nX][3] := aParcelas[nLinha][3]
					aParcelas[nX][6] := aParcelas[nLinha][6]
				Endif
			Next nX
		Endif

	Endif

	oParcelas:SetArray(aParcelas)
	//???????????????????????????????????????????????????????
	//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
	//???????????????????????????????????????????????????????
	If !lTk271Auto
		oParcelas:Refresh()
	Endif

	//Atualiza array de parcelas (analitico)
	If Type("oPgtosAna") == "O"
		oPgtosAna:SetArray(aParcelas)
		//???????????????????????????????????????????????????????
		//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
		//???????????????????????????????????????????????????????
		If !lTk271Auto
			oPgtosAna:Refresh()
		Endif
	Endif

	// Atualiza Array de parcelas (Sintetizado)
	If 	lVisuSint 	.AND. ;
		lUsaTef 	.AND. ;
		cTipTef == TEF_CLISITEF

		aPgtosSint := Tk273MontPgt(aParcelas)
		oPgtosSint:SetArray( aPgtosSint )
		//???????????????????????????????????????????????????????
		//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
		//???????????????????????????????????????????????????????
		If !lTk271Auto
			oPgtosSint:Refresh()
		Endif
	Endif

Endif

Return(.T.)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271Compl?Autor ?Vendas Clientes       ?Data ?8/01/02  ??
???????????????????????????????????????
??escri??o ?Tela de complemento da parcela de acordo com a Forma       ??
??         ?de pagamento escolhida                                     ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273Compl(	cComboForma	,cTipo		,aParcelas	,oParcelas,;
							aItens		,lHabilita	,cCodPagto	,lSigaCRD ,;
							lTLVReg2    ,lCheckPag)

Local cBanco 	:=SPACE(3),oBanco			//Banco
Local cAgencia	:=SPACE(5),oAgencia			//Agencia
Local cConta 	:=SPACE(10),oConta			//Conta
Local cCheque 	:=SPACE(15),oCheque			//Cheque
Local cRg 		:=SPACE(14),oRg				//RG
Local cFone 	:=SPACE(15),oFone			//Telefone
Local cComboAdm	:=SPACE(20),oComboAdm		//Administradora
Local aSAE    	:={}						//Array com as Administradoras cadastradas
Local cCartao	:=SPACE(20),oCartao			//Dados do cartao
Local dDtValid 	:=CTOD("  /  /  "),oDtValid	//Data de validade
Local cAutor	:=SPACE(6),oAutor			//Codigo de autorizacao
Local oDlg									//Tela
Local nPos 		:= 0                        //Posicao
Local lCheckBox	:=.F.,oCheckBox				//Checkbox
Local cDetalhe	:= SPACE(80)				//Detalhe
Local nOpca 	:= 0						//Opcao de escolha OK ou CANCELA
Local lShowDlg  := .T.						//Flag para exibicao da tela dos dados complementares
Local cFormCRD	:= SuperGetMv("MV_FORMCRD",,"CH/FI") //Formas de pagamento aceitas para analise de credito do SIGACRD
Local nLinha	:= 0  						//Linha selecionada no browse
Local nContx    := 0
Local cFormaPag := ""

DEFAULT lCheckPag := .F.

lTLVReg2  := .F. 						// Se alterar a forma de pagamento deve revalidar a regra de negocios.

//??????????????????????????????????????????
//?erifica se a regra de negocio cadastrada e valida com a tabela de preco escolhida?
//??????????????????????????????????????????
If ! FtRegraNeg(M->UA_CLIENTE	, M->UA_LOJA	, M->UA_TABELA	, cCodPagto	,;
				cTipo			, NIL			, .F., nil, .T.			)
	lTLVReg2  := .T.
Else
	For nContx := 1 To Len(aParcelas)
		If nContx <> oParcelas:nAt
		  	If !lCheckPag
				cFormaPag := aParcelas[nContx][3]
			Else
				If nContx > oParcelas:nAt
					cFormaPag := cTipo
				Else
					cFormaPag := aParcelas[nContx][3]
				Endif
			EndIf

		  	If !FtRegraNeg(	M->UA_CLIENTE			, M->UA_LOJA	, M->UA_TABELA	, cCodPagto	,;
				cFormaPag	, NIL	, .F.,nil , .T.			)
				lTLVReg2 := .T.
			Endif

		Endif
	Next nContx
Endif

//?????????????????????????????
//?Verifica qual eh a forma de visualizacao das parcelas ?
//?Sintetica ou analitica                                ?
//?????????????????????????????
If lVisuSint .AND. Type("oPgtosAna")=="O"
	//Visualizacao sintetica
	nLinha := oPgtosAna:nAt
Else
	//Visualizacao normal
	nLinha := oParcelas:nAt
Endif

//?????????????????????????????????????
//?e for a vista n?o tem informa??es complementares			    	  ?
//?e estiver usando TEF nao tem informacoes complementares para CC e CH  ?
//?????????????????????????????????????
If lUsaTef
	If (cTipo == "CC" .OR. cTipo == "CH") .OR. ("$" $ cTipo) .OR. !(cTipo $ "CCVAFICOCH")
		lShowDlg := .T.
	Endif
Endif

cDetalhe := aParcelas[nLinha,4]	//Detalhes da parcela - cartao, cheque, etc

If lShowDlg
	//?????????????????????????????????????
	//?e for pagamento em CHEQUE					     					  ?
	//?????????????????????????????????????
	If (cTipo == "CH")

		//?????????????????????????????????????
		//?e o valor digitado anteriormente n?o foi em CHEQUE limpo o complemento?
		//?????????????????????????????????????
		If Substr(cDetalhe,79,2) <> "CH"
			cDetalhe:=SPACE(80)
		Endif

		cBanco  := Substr(cDetalhe,1,3)
		cAgencia:= Substr(cDetalhe,4,5)
		cConta  := Substr(cDetalhe,9,10)
		cCheque := Substr(cDetalhe,19,15)
		cRg     := Substr(cDetalhe,34,14)
		cFone   := Substr(cDetalhe,48,15)

		DEFINE MSDIALOG oDlg FROM 10,20 TO 210,250 TITLE 'Complemento da Parcela' PIXEL STYLE DS_MODALFRAME  //"Complemento da Parcela"

			@05,10 SAY 'Banco' OF oDlg PIXEL //"Banco"
			@05,47 MSGET oBanco VAR cBanco Picture "999" SIZE 40,8 OF oDlg PIXEL When lHabilita RIGHT

			@16,10 SAY 'Agencia' OF oDlg PIXEL //"Agencia"
			@16,47 MSGET oAgencia VAR cAgencia Picture "99999" SIZE 40,8 PIXEL OF oDlg When lHabilita RIGHT

			@26,10 SAY 'Conta' OF oDlg PIXEL //"Conta"
			@26,47 MSGET oConta VAR cConta Picture "9999999999" SIZE 60,8 PIXEL OF oDlg When lHabilita RIGHT

			@36,10 SAY 'Cheque' OF oDlg PIXEL //"Cheque"
			@36,47 MSGET oCheque VAR cCheque Picture "999999999999999" SIZE 60,8 PIXEL OF oDlg When lHabilita RIGHT

			@46,10 SAY 'RG' OF oDlg PIXEL //"RG"
			@46,47 MSGET oRg VAR cRg Picture "@R 99.999.999.999" SIZE 60,8 PIXEL OF oDlg When lHabilita RIGHT

			@56,10 SAY 'Telefone' OF oDlg PIXEL //"Telefone"
			@56,47 MSGET oFone VAR cFone  Picture "@R (999) 9999-9999" SIZE 60,8 PIXEL OF oDlg When lHabilita RIGHT

			@68,10 CHECKBOX oCheckBox VAR lCheckBox PROMPT 'Aplica em todas as parcelas' SIZE 90,10 OF oDlg PIXEL WHEN (nLinha <> Len(aParcelas))  //"Aplica em todas as parcelas"

			DEFINE SBUTTON FROM 85,055 TYPE 1 ACTION (nOpca := 1,oDlg:End()) ENABLE OF oDlg

			DEFINE SBUTTON FROM 85,085 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg

		    // Desabilita a tecla ESC
		    oDlg:LESCCLOSE := .F.

		ACTIVATE MSDIALOG oDlg CENTER

		If nOpcA == 1
			cDetalhe := cBanco + cAgencia + cConta + cCheque + cRg + cFone + SPACE(16) + cTipo
		Endif

		If !Empty(cCheque)
			nAux := VAL(cCheque)
		Else
			nAux := 0
		EndIf

	ElseIf (cTipo == "CC") .OR. cTipo $ cFormCRD

		//?????????????????????????????????????
		//?arrega as administradora de cart?o de cr?dito					      ?
		//?????????????????????????????????????
		DbSelectArea("SAE")
		DbSetOrder(1)
		DbSeek(xFilial("SAE"))
		While !SAE->(Eof()) .AND. SAE->AE_FILIAL == xFilial("SAE")
			AADD(aSAE,AE_COD+"-"+AE_DESC)
			SAE->(DbSkip())
		End

		//??????????????????????????????????????????
		//?e o valor digitado ou gravado anteriormente n?o foi em CARTAO limpo o complemento?
		//??????????????????????????????????????????
		If Substr(cDetalhe,79,2) $ "CH"
			cDetalhe:=SPACE(80)
		Endif

		cComboAdm 	:=Substr(cDetalhe,1,AT("*",cDetalhe)-1)
		cCartao 	:=Substr(cDetalhe,AT("*",cDetalhe),16)
		dDtValid	:=CTOD(Substr(cDetalhe,AT("*",cDetalhe)+16,8))
		cAutor 	 	:=Substr(cDetalhe,AT("*",cDetalhe)+16+8,6)


		//???????????????????????????????????????
		//?e o conteudo da administradora nao estiver vazio, seleciona o valor gravado?
		//???????????????????????????????????????

		If !Empty(cComboAdm)
			nPos:= Ascan(aSAE,{|x| Upper(x) == Upper(cComboAdm)})
			If nPos > 0
				cComboAdm:= aSAE[nPos]
			Endif
		Endif

		DEFINE MSDIALOG oDlg FROM 10,20 TO 210,300 TITLE 'Complemento' PIXEL STYLE DS_MODALFRAME  //"Complemento da Parcela"

			@05,10 SAY 'Adminstradora' OF oDlg PIXEL //"Administradora"
			@05,57 MSCOMBOBOX oComboAdm VAR cComboAdm ITEMS aSAE SIZE 80,8 PIXEL OF oDlg When lHabilita

			@20,10 SAY 'Cartao' OF oDlg PIXEL //"Cart?o"
			@20,57 MSGET oCartao  VAR cCartao Picture "@R XXXXXXXXXXXXXXXX" SIZE 80,8 PIXEL OF oDlg VALID !Empty(cCartao) When lHabilita

			@35,10 SAY 'Validade' OF oDlg PIXEL  //"Validade"
			@35,57 MSGET oDtValid VAR dDtValid Picture "99/99/99" SIZE 50,8 PIXEL OF oDlg VALID ValDtCC(dDtValid) When lHabilita

			@50,10 SAY 'Autorizacao' OF oDlg PIXEL  //"Autoriza??o"
			@50,57 MSGET oAutor  VAR cAutor Picture "@!"  SIZE 40,8 PIXEL OF oDlg When lHabilita

			@65,10 CHECKBOX oCheckBox VAR lCheckBox PROMPT 'Aplica em todas as parcelas' SIZE 90,10 OF oDlg PIXEL WHEN lHabilita  //"Aplica em todas as parcelas"

			//Confirmacao - Botao de Ok
			DEFINE SBUTTON FROM 80,075 TYPE 1 ACTION (IIF(!Empty(cCartao) .And. ValDtCC(dDtValid),(nOpca:= 1,oDlg:End()),nil)) ENABLE OF oDlg

			DEFINE SBUTTON FROM 80,105 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg

		    // Desabilita a tecla ESC
		    oDlg:LESCCLOSE := .F.

		ACTIVATE MSDIALOG oDlg CENTER

		If nOpcA == 1
			cDetalhe := cComboAdm + "************" + If(!Empty(cCartao),SubStr(cCartao,13,4),"****") +;
						DTOC(dDtValid) + cAutor + SPACE(28) + cTipo
		Endif
	Endif

Else
	nOpca := 1
Endif

If nOpca == 1
	If lCheckBox

		For nPos := 1 TO Len(aParcelas)

			//?????????????????????????????????????
			//?erifico se a parcela e igual a parcela preenchida e se nao 			   ?
			//? a primeira, pois o numero sequencial dos cheques e a partir da segunda?
			//?????????????????????????????????????
		    If (cTipo == "CH")
		    	If (nPos > 1)
		    		nAux ++
		    	Endif

				cDetalhe := cBanco + cAgencia + cConta + StrZero(nAux,Len(cCheque)) + cRg + cFone + SPACE(16) + cTipo
			Endif

			aParcelas[nPos,3] := cTipo
			aParcelas[nPos,4] := cDetalhe

		Next nPos

	Else

		nPos := Ascan( aItens, { |x| x[1] = cComboForma } )
		If nPos > 0
			aParcelas[nLinha,3] := aItens[nPos][2]	//Forma de pagamento
			aParcelas[nLinha,4] := cDetalhe			//Detalhes
		Endif

	Endif
	//???????????????????????????????????????????????????????
	//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
	//???????????????????????????????????????????????????????
	If !lTk271Auto
		oParcelas:Refresh()
    Endif

Else
	If !(cTipo $ "CC/CH" .OR. cTipo $ cFormCRD)

		//????????????????????????????????
		//?Caso nao seja necessario o complemento e a parcela nao      ?
		//?or cheque e nem cartao altera a terceira coluna do aParcelas?
		//?com a forma de pagto escolhida.                             ?
		//????????????????????????????????
		nPos := Ascan( aItens, { |x| x[1] = cComboForma } )
		If nPos > 0
			aParcelas[nLinha,3] := aItens[nPos][2]		//Forma de Pagamento
			aParcelas[nLinha,4] := cDetalhe				//Detalhes
		Endif
	Else
		nPos := Ascan( aItens, { |x| x[2] = aParcelas[nLinha,3] } )
		If nPos > 0
			cComboForma := aItens[nPos][1]
			cTipo 		:= aItens[nPos][2]
		EndIf
	EndIf

	//???????????????????????????????????????????????????????
	//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
	//???????????????????????????????????????????????????????
	If !lTk271Auto
		oParcelas:Refresh()
	Endif

Endif

Return(.T.)

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?alDtCC   ?utor  ?endas / CRM        ?Data ? 02/17/10   ??
???????????????????????????????????????
??esc.     ?erifica se a data do cartao e menor que a data do sistema  ??
??         ?u a data do computador                                     ??
???????????????????????????????????????
??so       ?MKA273C                                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function ValDtCC(dDtValid)
Local lRet := .T.

If Empty(dDtValid) .Or. (dDtValid < dDataBase) .Or. (dDtValid < Date())
	Help(" ",1,"DATA_INVAL")
	lRet  := .F.
EndIf

Return lRet



/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271ValData   ?Autor ?Vendas Clientes  ?Data ?2/05/00  ??
???????????????????????????????????????
??escri??o ?erifica se a data digitada e maior que a anterior   	      ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273ValData(	dDataAnt	,dDtParcela		,oDtParcela		,aParcelas,;
								oParcelas	,aItens			,cComboForma)

Local nTamPgtos := Len(aParcelas)
Local nPos 		:= 1					//Posicao dentro do aParcelas
Local lRet 		:= .T.					//Retorno da funcao

If lVisuSint .AND. Type("oPgtosAna")=="O"
	nPos := oPgtosAna:nAt
Else
	nPos := oParcelas:nAt
Endif

If Empty(dDtParcela)
	dDtParcela:= dDataAnt
	//???????????????????????????????????????????????????????
	//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
	//???????????????????????????????????????????????????????
	If !lTk271Auto
		oDtParcela:Refresh()
	Endif
	lRet := .F.

ElseIf (nPos <= nTamPgtos) .AND. (nPos > 1)
	If dDtParcela < aParcelas[nPos-1,1]
		dDtParcela := dDataAnt
		lRet := .F.
	Else
		nPos := 0
		nPos := Ascan(aItens,{|aItens| aItens[1] == cComboForma})
		If nPos > 0
			If ("$" $ aItens[nPos][2] ) .AND. (dDtParcela > dDataBase)
				Help( " ", 1, "NOPRAZO" )
				lRet := .F.
			Endif
		Endif
	Endif

Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k273ParcelaOk ?Autor ?Vendas Clientes  ?Data ?1/05/00  ??
???????????????????????????????????????
??escri??o ?erifica se total das parcelas esta igual ao valor liquido  ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273ParcelaOk( aParcelas  	,nEntrada   ,nFinanciado  	,nValNFat   ,;
                                cTipoOper  	,cCodPagto	,cCodTransp		,cCob		,;
								cEnt		,cCidadeC	,cCepC			,cBairroC	,;
								cBairroE	,cCidadeE	,cCepE			,cUfE       ,;
								cTransp		,oTransp)

Local nCont		:= 0								// Contador
Local nJuros	:= 0								// Total dos juros da condicao escolhida
Local lTmkDados	:= FindFunction("U_TMKDADOS")		// P.E. para TLV
Local lAuxRet	:= .T.								// Retorno auxiliar do P.E. TMKDADOS
Local lRet		:= .T.                              // Retorno da funcao


// validação de condição de pagamento por Número de Famílias de produtos OU Estado do cliente
If !(U_MTXXPG(.F.))
	MsgAlert("Condição de pagamento não válida! Não atingiu o número de famílias de produtos suficiente, ou estado(UF) do cliente não válida para esta condicão.")
	Return(.F.)
EndIf

//????????????????????????????????????
//?erifica se o campo condicao de pagamento foi preenchido corretamente?
//????????????????????????????????????

If Empty(cCodPagto)

	Help(" ",1,"FALTA_PGTO")
	lret := .F.
EndIf


lRet:= TK273ValTrans(cCodTransp,cTransp,oTransp)


//???????????????????????????
//?erifica se a Condicao esta bloqueada ou nao       ?
//???????????????????????????

If !Empty(cCodPagto)
	 DbSelectArea("SE4")
	 DbSetOrder(1)
	 If DbSeek(xFilial("SE4")+cCodPagto)
		If SE4->E4_MSBLQL=="1"
			Help(" ",1,"REGBLOQ")
			lRet	:= .F.
		Endif
	EndIf
EndIf

//Tratativa para desconsiderar o valor de desconto na parcela quando o orcamento utilizar o credito do SAC.
If M->UA_ZCRESAC == "S"

    If (aValores[TOTAL] + aValores[02]) > SE4->E4_SUPER .AND. SE4->E4_SUPER <> 0 .AND. SuperGetMv("MV_CNDPLIM",,"1") == "1"
        Help(" ","1","LJLIMSUPER")
        lRet	:= .F.
    ElseIf (aValores[TOTAL] + aValores[02]) < SE4->E4_INFER .AND. SE4->E4_INFER <> 0 .AND. SuperGetMv("MV_CNDPLIM",,"1") == "1"
        Help(" ","1","LJLIMINFER")
        lRet	:= .F.
    Endif

Else

    If aValores[TOTAL] > SE4->E4_SUPER .AND. SE4->E4_SUPER <> 0 .AND. SuperGetMv("MV_CNDPLIM",,"1") == "1"
        Help(" ","1","LJLIMSUPER")
        lRet	:= .F.
    ElseIf aValores[TOTAL] < SE4->E4_INFER .AND. SE4->E4_INFER <> 0 .AND. SuperGetMv("MV_CNDPLIM",,"1") == "1"
        Help(" ","1","LJLIMINFER")
        lRet	:= .F.
    Endif

EndIf

If !Empty(aParcelas)

	For nCont := 1 To Len(aParcelas)

		nJuros += Round(NoRound(aParcelas[nCont][2],4),2)

		//????????????????????????????
		//?erifica se existe parcela DINHEIRO fora da data     ?
		//????????????????????????????
		If ("$" $ aParcelas[nCont][3]) .AND. (nCont > 1) .AND. (aParcelas[nCont][1] > dDataBase)
			Help( " ", 1, "NOPRAZO" )
			lRet  := .F.
			Exit
		Endif

		//????????????????????????????
		//?erifica se as Datas das parcelas estao corretas     ?
		//????????????????????????????
		If nCont > 1
			If aParcelas[nCont][1] < aParcelas[nCont-1][1]
				Help(" ",1,"DATA_INVAL")
				lRet  := .F.
				Exit
			Endif
		Endif
	Next nCont

	If lRet
	   If NoRound(nJuros,2) <> aValores[BASEDUP]
		  Help( " ", 1, "TK010VALOK" )
		  lRet  := .F.
	   Endif
	Endif

	If lRet .AND. cTipoOper == "1"   //Faturamento

		For nCont := 1 To Len(aParcelas)
			If !IsMoney(aParcelas[nCont][3]) .AND. AllTrim(aParcelas[nCont][3]) <> "CH"

				If lUsaTef .AND. (cTipTef <> NIL)
					//Se o atendimento for com TEF e for CLISITEF nao verifica a Administradora, pois a mesma e informada durante a transacao
					If cTipTef <> TEF_CLISITEF

						If Empty(aParcelas[nCont][4]) .OR. SUBSTR(aParcelas[nCont][4],1,1) == "*"
							//"Selecione uma administradora financeira para a parcela "
							MsgStop('Selecione uma adm. financeira para a parcela'+AllTrim(STR(nCont))+".")
							lRet  := .F.
							Exit
						Endif

					Endif
				Endif

			Endif
		Next nCont

	Endif
Endif

If lRet .AND. lTMKDADOS
	lAuxRet	:= lRet

	lAuxRet := U_TMKDADOS(	cCodPagto	,cCodTransp	,cCob		,cEnt		,;
							cCidadeC	,cCepC		,cBairroC	,cBairroE	,;
							cCidadeE	,cCepE		,cUfE		,aParcelas 	)
	If (ValType(lAuxRet) == "L")
		lRet := lAuxRet
	Endif
Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271Data ?Autor ?Vendas Clientes       ?Data ?6/10/00  ??
???????????????????????????????????????
??escri??o ?erifica se as parcelas correspondem ao Tipo de pagamento	  ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function TK273Data(cComboForma,aParcelas,aItens,dDtParcela)

Local cForma := ""		//Forma de pagamento
Local nPos   := 0		//Contador
Local lRet	 := .T.		//Retorno da funcao

nPos 	:= Ascan(aItens,{|X| AllTrim(X[1]) == AllTrim(cComboForma) })
If nPos > 0
	cForma 	:= aItens[nPos][2]	//Forma de pagamento no ARRAY
	If ("$" $ SubStr(cForma,1,2)) .AND. ( Len(aParcelas) <> 1 ) .AND. (dDtParcela > dDataBase)
		Help( " ", 1, "NOPRAZO" )
		lRet := .F.
	Endif
Endif

Return(lRet)

/*/
?????????????????????????????????????????
?????????????????????????????????????????
?????????????????????????????????????????
??un??o	 ?k271CompVal   ?Autor ?Vendas Clientes      ?Data ?17/09/01 ??
?????????????????????????????????????????
??escri??o ?otina de Verifica??o dos valores dae parcelas		          ??
?????????????????????????????????????????
??so       ?OMENTE TELEVENDAS 								     		  ??
?????????????????????????????????????????
?????????????????????????????????????????
?????????????????????????????????????????
/*/
Static Function Tk273CompVal(aParcelas	, nLiquido	, nVlJur	, cCodPagto	,;
							 cCodAnt    )
Local lRet   := .F.			//Retorno da funcao
Local nTotAux:= 0           //Total das parcelas

If (Len(aParcelas) > 0)
	Aeval(aParcelas,{|aVal|nTotAux+= aVal[2]})	//Soma todas as colunas 2 do aParcelas (valor)

	If (nTotAux == nLiquido + nVlJur)
		lRet:= .T.
	Endif

   	If cCodPagto <> cCodAnt
		aParcelas:= {}
		lRet:= .F.
	Endif
Endif
Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271AtuTransp ?Autor ?Vendas Clientes  ?Data ?6/05/00  ??
???????????????????????????????????????
??escri??o ?tualiza o nome da Transportadora na tela de Cond.Pagamento ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273AtuTransp(cCodTransp,cTransp,oTransp)

Local lRet 			:= .F.										//Retorno da funcao
Local lTMKVLDSA4  	:= ExistBlock("TMKVLDSA4")				// P.E. para TLV na validacao do codigo de transportadora - antes da validacao padrao do sistema

cTransp := CRIAVAR("A4_NOME",.F.)

If Empty(cCodTransp)
	lRet := .T.
Else

	//????????????????????????????????????????????????????????
	//?alida o P.E. antes da validacao padrao do sistema que exige que o codigo da transportadora exista no cadastro?
	//????????????????????????????????????????????????????????
	If lTMKVLDSA4
		lRet := ExecBlock("TMKVLDSA4",.F.,.F.,{cCodTransp})

		If (ValType(lRet) <> "L")
			Return(.F.)
		ElseIf !lRet
			Return(.F.)
		Endif
	Endif

	lRet:= Tk273ValTrans(cCodTransp,@cTransp,oTransp)

Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271Estado    ?Autor ?Vendas Clientes  ?Data ?6/11/01  ??
???????????????????????????????????????
??escri??o ?alida se o usuario informou o ESTADO correto 			  ??
???????????????????????????????????????
??so       ?OMENTE TELEVENDAS 								     	  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273Estado(cUf)
Local lRet := .F.		//Retorno da funcao

//??????????????????????????
//?e o Operador preencheu o estado valida o conteudo?
//??????????????????????????
If !Empty(cUf)
	DbSelectArea("SX5")
	DbSetOrder(1)
	If DbSeek(xFilial("SX5")+"12"+cUf)
	   lRet := .T.
	Endif
Else
    lRet := .T.
Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271CidC      ?Autor ?Vendas Clientes  ?Data ?7/12/01  ??
???????????????????????????????????????
??escri??o ?alidacao para o MUNICIPIO de COBRANCA        			  ??
???????????????????????????????????????
??so       ?OMENTE TELEVENDAS 								     	  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273CidC(oCidadeC,cCidadeC)

Local lRet 	  := .T.								// Retorno da funcao
Local aCidC	  := {cCidadeC}							// Cidade de Cobrancao
Local lTMKCIDC:= FindFunction("U_TMKCIDC")			// P.E. para TLV

If lTMKCIDC
	lRet 	 := .F.
	cCidadeC := U_TMKCIDC(aCidC)
	If !Empty(cCidadeC)
		lRet := .T.
	Endif
	//??????????????????????
	//?e nao estiver usando a entrada automatica?
	//??????????????????????
	If !lTk271Auto
		oCidadeC:Refresh()
	Endif
Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271CidE      ?Autor ?Vendas Clientes  ?Data ?7/12/01  ??
???????????????????????????????????????
??escri??o ?alidacao para o MUNICIPIO de ENTREGA         			  ??
???????????????????????????????????????
??so       ?OMENTE TELEVENDAS 								     	  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273CidE(oCidadeE,cCidadeE)
Local lRet 	  := .T.							// Retorno da funcao
Local aCidE	  := {cCidadeE}						// Cidade de Entrega
Local lTMKCIDE:= FindFunction("U_TMKCIDE")		// P.E. para TLV

If lTMKCIDE
	lRet	 := .F.
	cCidadeE := U_TMKCIDE(aCidE)
	If !Empty(cCidadeE)
		lRet := .T.
	Endif
	//??????????????????????
	//?e nao estiver usando a entrada automatica?
	//??????????????????????
	If !lTk271Auto
		oCidadeE:Refresh()
	Endif
Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271CepC      ?Autor ?Vendas Clientes  ?Data ?7/12/01  ??
???????????????????????????????????????
??escri??o ?alidacao para o CEP de Cobranca              			  ??
???????????????????????????????????????
??so       ?OMENTE TELEVENDAS 								     	  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273CepC(	cCepC	,oCepC	,cCidadeC	,oCidadeC,;
					cUfC	,oUfC	,cBairroC	,oBairroC)
Local lRet 	  := .T.                  					//Retorno da funcao
Local aCepC	  := {cCepC,cCidadeC,cUfC,cBairroC}			//Cep , Cidade , estado e bairro de Cobranca
Local lTMKCEPC:= FindFunction("U_TMKCEPC")				//P.E.

If lTMKCEPC
	lRet	:= .F.
	aCepC   := U_TMKCEPC(aCepC)
	cCepC	:= aCepC[1]
	cCidadeC:= aCepC[2]
	cUfC	:= aCepC[3]
	cBairroC:= aCepC[4]
	If !Empty(cCepC)
		lRet	:= .T.
		//??????????????????????
		//?e nao estiver usando a entrada automatica?
		//??????????????????????
		If !lTk271Auto
			oCepC:Refresh()
			oCidadeC:Refresh()
			oUfC:Refresh()
			oBairroC:Refresh()
		Endif
	Endif
Endif
Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k271CepE      ?Autor ?Vendas Clientes  ?Data ?7/12/01  ??
???????????????????????????????????????
??escri??o ?alidacao para o CEP de Entrega               			  ??
???????????????????????????????????????
??so       ?OMENTE TELEVENDAS 								     	  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273CepE(	cCepE	,oCepE	,cCidadeE	,oCidadeE,;
					cUfE	,oUfE	,cBairroE	,oBairroE)

Local lRet	  := .T.				  				// Retorno da funcao
Local aCepE	  := {cCepE,cCidadeE,cUfE,cBairroE}		// Cep , Cidade , estado e bairro de Cobranca
Local lTMKCEPE:= FindFunction("U_TMKCEPE")          // P.E. do TLV

If lTMKCEPE
	lRet	:= .F.
	aCepE 	:= U_TMKCEPE(aCepE)
	cCepE 	:= aCepE[1]
	cCidadeE:= aCepE[2]
	cBairroE:= aCepE[4]
	If !Empty(cCepE)
		lRet 	:= .T.
		//??????????????????????
		//?e nao estiver usando a entrada automatica?
		//??????????????????????
		If !lTk271Auto
			oCepE:Refresh()
			oCidadeE:Refresh()
			oBairroE:Refresh()
		Endif
    Endif
Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??uncao?k271CalcAcre ?utor  ?endas Clientes     ?Data ? 06/20/02   ??
???????????????????????????????????????
??esc. ?reenche o acr?cimo de cada produto com o acr?cimo da condicao??
??     ?e pagamento.                                                   ??
???????????????????????????????????????
??aram.?xpN1 : - Taxa de acrescimo da condicao de pagamento.           ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
??nalista  ?Data/Bops/Ver ?anutencao Efetuada                         ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273CalcAcre(nTxJuros,nVlJur)

Local cPrcFiscal:= TkPosto(M->UA_OPERADO,"U0_PRECOF") 		//Preco fiscal bruto 1=SIM / 2=NAO
Local cAcrescimo:= TkPosto(M->UA_OPERADO,"U0_ACRESCI") 		//Acrescimo 1=ITEM / 2=NAO
Local lRet 		:= .F.                                      //Retorno da funcao

//???????????????????????????????????
//?e o posto de venda nao recalcula o unitario nao pode dar acrescimo?
//???????????????????????????????????
If AllTrim(cAcrescimo) == "2" .AND. (nVlJur > 0 .OR. nTxJuros > 0)   	   // Acrescimo = 2 - Nao
	//??????????????????????
	//?e nao estiver usando a entrada automatica?
	//??????????????????????
	If !lTk271Auto
		Help( " ", 1, "NAO_ACRESC")
	Endif
	Return(lRet)
ElseIf AllTrim(cPrcFiscal) == "1"  // Preco Fiscal Bruto NAO (NAO ALTERA O UNITARIO NAO PODE DAR ACRESCIMO)
	//??????????????????????
	//?e nao estiver usando a entrada automatica?
	//??????????????????????
	If !lTk271Auto
		Help( " ", 1, "NAO_ACRESC")
	Endif
	Return(lRet)
Endif

If Len(aCols) > 0
	//??????????????????????????????????????????????
	//?oga o  ACRESCIMO financeiro calculado no campo "Acrescimo" do rodape da tela             ?
	//?sso e feito assim para que na emissao da NF o SIGAFAT nao calcule duas vezes o acrescimo ?
	//??????????????????????????????????????????????
	aValores[ACRESCIMO] := nVlJur
	Tk273RodImposto("NF_DESPESA",aValores[DESPESA])
Endif

lRet := .T.

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?MKA273TipoNove ?utor  ?endas Clientes    ?Data ?7/10/02??
???????????????????????????????????????
??escricao ?era as parcelas para venda do tipo 9                       ??
???????????????????????????????????????
??so       ?AP811                                                      ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function TK273TipoNove(	nOpc		,nLiquido	,nVlJur		,cForma,;
						cE4_COND	,cNumTlv	,aArray9	,lTipo9,;
						lCalcula)

Local aArea		:= GetArea()				//Salva a area anterior
Local aHeadAnt 	:= aClone(aHeader)			//Salva o aHeader
Local aColsAnt 	:= aClone(aCols)			//Salva o aCols
Local nAnt		:= n

Local lTmkTipo9 := ExistBlock("TMKTIPO9")	//Controle de ponto de entrada

Local oDlg									//Tela
Local oGetParc								//Getdados da Parcela
Local nOpcA		:= 0						//Opcao de escolha  OK - CANCELA
Local nLinha	:= 0						//Contador de Linha
Local aTipo9 	:= {}						//Array com as parcelas
Local nTotal 	:= nLiquido+nVlJur			//Valor Total do pedido
Local nValParc  := 0						//Valor Total da Parcela
//Local nResto	:= 0						//Resto
Local nCabeca   := 0						//Tamanho do aHeader

//????????????????????????????
//?e no TIPO 9  da condicao estiver especificado "%" so ?
//?ode ser preenchido os valores das parcelas em %      ?
//????????????????????????????
Local lValor	:= !(AllTrim(cE4_COND) $ "%")			//TRUE - so pode preencher em Dinheiro / FALSE - so pode preencher em %
Local nOpAux    := nOpc
SaveInter()
Private aRotina := {{"Pesquisar", "AxPesqui", 0, 1},;
                    {"Visualizar", "AxVisual", 0, 2},;
                    {"Incluir", "AxInclui", 0, 3},;
                    {"Alterar", "AxAltera", 0, 4},;
                    {"Excluir", "AxDeleta", 0, 5}}


lCalcula := .F.

aHeader := {}
aCols   := {}
n		:= 1

If lTipo9
	aTipo0 := aArray9
EndIf

If lValor
	AADD(aHeader,{	'Valor da Parcela',;					//01 - X3TITULO()            //"Valor da Parcela"
					"L4_VALOR",;							//02 - X3_CAMPO
					PesqPict("SL4","L4_VALOR"),;   			//03 - X3_PICTURE
				    TamSX3("L4_VALOR")[1]     ,;			//04 - X3_TAMANHO
					TamSX3("L4_VALOR")[2]     ,;			//05 - X3_DECIMAL
					"Positivo()",;							//06 - X3_VALID
					"??????????????"+chr(65533),;						//07 - X3_USADO
					"N",;									//08 - X3_TIPO
					"",;									//09 - X3_ARQUIVO
					"" 	} )									//10 - X3_CONTEXT
Else
	AADD(aHeader,{	'Percentual da Parcela',;								//01 - X3TITULO()		//"Percentual da Parcela"
					"L4_COMP",;								//02 - X3_CAMPO
					"@E 999.99",;							//03 - X3_PICTURE
					5,;										//04 - X3_TAMANHO
					2,;										//05 - X3_DECIMAL
					"Positivo()",;							//06 - X3_VALID
					"??????????????"+chr(65533),;						//07 - X3_USADO
					"N",;									//08 - X3_TIPO
					"",;									//09 - X3_ARQUIVO
					"" 	} )									//10 - X3_CONTEXT
Endif

AADD(aHeader,{	'Data',;												//01 - X3TITULO()		//"Data"
				"L4_DATA",;												//02 - X3_CAMPO
				"",;													//03 - X3_PICTURE
				8,;														//04 - X3_TAMANHO
				0,;														//05 - X3_DECIMAL
				"NaoVazio()",;											//06 - X3_VALID
				"??????????????"+chr(65533),;										//07 - X3_USADO
				"D",;													//08 - X3_TIPO
				"",;													//09 - X3_ARQUIVO
				"" 	} )													//10 - X3_CONTEXT

//?????????????????????
//?e as parcelas devem ser recalculadas  ?
//?????????????????????
If (lCalcula)
	//???????????????????
	//?Monta o Array com 1 elemento vazio?
	//???????????????????
	aCols := Array(1, Len(aHeader) + 1)
	aCols[1][1] := 0
	aCols[1][2] := CTOD("")
	aCols[1][3] := .F.			//Linha de controle de DELECAO

	nOpAux := 3
//??????????
//?e for inclusao  ?
//??????????
ElseIf (nOpc == 3)
	If Len(aTipo9) > 0

	   nCabeca := Len(aHeader)+1
	   For nLinha := 1 TO LEN(aTipo9)
	   		Aadd(aCols,{ 0,CTOD(""),.F. })
	       	aCols[nLinha][1] := IIF(lValor,aTipo9[nLinha][2],aTipo9[nLinha][5])  //Valor, Percentual
	       	aCols[nLinha][2] := aTipo9[nLinha][1]  //Data
	       	aCols[nLinha][3] := .F.
	   Next nLinha

	Else
		//?????????????????????????
		//?Na inclusao Monta o Array com 1 elemento vazio?
		//?????????????????????????
		aCols := Array(1, Len(aHeader) + 1)
		aCols[1][1] := 0
		aCols[1][2] := CTOD("")
		aCols[1][3] := .F.			//Linha de controle de DELECAO
	Endif

//?????????????
//?lteracao - Visualizacao?
//?????????????
Elseif (nOpc == 4)
	//??????????????????????????????
	//?Monta as parcelas de acordo com a condicao de pagamento ?
	//??????????????????????????????
	nValParc  := 0
	nLinha 	  := 0
	DbSelectArea("SL4")
	DbSetOrder(1)
	DbSeek(xFilial("SL4")+cNumTlv+"SIGATMK ")
	While (!SL4->(Eof())) .AND. (xFilial("SL4") == SL4->L4_FILIAL) 		.AND. ;
						 (SL4->L4_NUM == cNumTlv) 					.AND. ;
						 (AllTrim(SL4->L4_ORIGEM) == "SIGATMK")

		nLinha++
   		Aadd(aCols,{ 0,CTOD(""),.F. })

		aCols[nLinha][1] := IIF(lValor,L4_VALOR,((L4_VALOR/SUA->UA_VLRLIQ) * 100))
		aCols[nLinha][2] := L4_DATA
		aCols[nLinha][3] := .F.			//Linha de controle de DELECAO

		nValParc += SL4->L4_VALOR

		SL4->(DbSkip())
	End

Endif

//??????????????????????????????????????????
//?onto de entrada para possibilitar alteracao do acols e troca da opcao da operacao?
//??????????????????????????????????????????
If lTmkTipo9
	nOpAux := ExecBlock("TMKTIPO9",.F.,.F.,{nOpAux} )

	//??????????????????????????????????????????
	//?rotecao para retorno do ponto de entrada                                         ?
	//??????????????????????????????????????????
	If Valtype(nOpAux) <> "N"
		nOpAux    := nOpc
	Endif

Endif

n := Len(aCols)

DEFINE MSDIALOG oDlg FROM 10,20 TO 200,450 TITLE 'Valor da parcela e vencimento' PIXEL //"Valor da Parcela e Vencimento"

	oGetParc := MSGetDados():New(01,02,80,215,nOpAux,{|| Tk273ParcLin(lValor)},"AlwaysTrue","",.T.,,,.F.,SuperGetMv("MV_NUMPARC"))
	oGetParc:oBrowse:bDelete:={ || aCols[n,Len(Acols[n])]:=!aCols[n,Len(aCols[n])],"AlwaysTrue",oGetParc:oBrowse:Refresh(.F.)}
	oGetParc:oBrowse:Refresh(.T.)

	DEFINE SBUTTON FROM 81,150 TYPE 1 ACTION (nOpcA := 1,IIF(Tk273ValTp9(nTotal,lValor,@aTipo9,cForma),oDlg:End(),nOpcA:=0)) ENABLE OF oDlg

	DEFINE SBUTTON FROM 81,185 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg

ACTIVATE MSDIALOG oDlg CENTER

//?????????????????????????????????????????
//?e o Operador nao confirmou as parcelas da condicao - limpa o retorno do array ?
//?????????????????????????????????????????

If nOpcA <> 1
	If Len(aArray9) == 0
		AADD(aTipo9,{	dDataBase	,;	// 1 - Data
						nTotal		,;	// 2 - Valor
						cForma		,;	// 3 - Forma de Pagamento
						Space(80)	,;	// 4 - Complemento
						0			,;	// 5 - Valor R$ ou %
						Space(01)	})	// 6 - ID Cartao (para visualiz. sintetica)
	Endif
Endif

aHeader	:= aClone(aHeadAnt)
aCols 	:= aClone(aColsAnt)
n		:= nAnt

RestArea(aArea)
RestInter()
Return(aTipo9)

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?k273ParcLin?utor  ?endas Clientes   ?Data ? 07/11/02   ??
???????????????????????????????????????
??escricao ?alidacao da linha da GETDADOS das parcelas do tipo 9       ??
???????????????????????????????????????
??so       ?ELEVENDAS                                                  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273ParcLin(lValor)

Local lRet := .F.		//Retorno da funcao

//?????????????
//?e for uma linha valida?
//?????????????
If !aCols[n][Len(aHeader)+1]
	If (aCols[n][1] == 0)
		If lValor //Se for TRUE indica que apenas os valores em DINHEIRO podem ser preenchidos
			Help(" ",1,"TMKTIP901" ) //"Informe o valor em Dinheiro porque essa ?uma regra da condi?o de pagamento escolhida"
		Else	//Se apenas os valores em PERCENTUAL pode ser preenchidos
			Help(" ",1,"TMKTIP902" ) //"Informe o valor em % porque essa ?uma regra da condi?o de pagamento","Aten?o")
		Endif
		Return(lRet)
	Endif

	If Empty(aCols[n][2]) .OR. (aCols[n][2] < dDataBase)
		Help(" ",1,"TMKTIP903" ) //"A data esta incorreta"
		Return(lRet)
	Endif
Endif

lRet := .T.

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?k273ValTp9 ?utor  ?endas Clientes   ?Data ? 07/11/02   ??
???????????????????????????????????????
??escricao ?alidacao da linha da GETDADOS das parcelas do tipo 9       ??
???????????????????????????????????????
??so       ?AP811                                                      ??
???????????????????????????????????????
??intaxe   ?Tk271Pagamento(ExpN1, ExpL2,	 ExpA3,	 ExpC4)               ??
???????????????????????????????????????
??arametros?ExpN1 = Valor total do parcelamento.                  	  ??
??         ?ExpL2 = Se esta em valor ou em porcentagem            	  ??
??         ?ExpA3 = Array com o valor e a data das parcelas       	  ??
??         ?ExpC4 = Forma de pagamento utilizada nas parcela      	  ??
???????????????????????????????????????
??etorno   ?Sempre retorna .T. (Verdadeiro)                       	  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273ValTp9(nTotal,lValor,aTipo9,cForma)

Local lRet	 		:= .F.			// Retorno da funcao
Local nLinha 		:= 0  			// Contador da Linha
Local nValParc 		:= 0 			// Valor de cada parcela informada em % ou R$
Local nValTotal		:= 0 			// Valor total das parcelas informadas pelo Operador
Local dData			:= dDatabase	// Data Inicial
Local nLenAux  		:= LEN(aCols)	// Contador auxiliar para o FOR
Local nResto 		:= 0			// Diferenca entre o valor total e a somatoria das parcelas
Local nUltLinha		:= 1			// N?ero da ?tima linha v?ida
Local cParcela  	:= "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0"
Local nParcelas 	:= GETMV("MV_NUMPARC")
Local cChave 		:= ""
Local cChave1		:= ""
Local nDecE1Vlr 	:= TamSX3( "E1_VALOR"  )[2]

If nParcelas > 4
	cChave := "C5_DATA"+Subs(cParcela,nParcelas,1)
	cChave1:= "C5_PARC"+Subs(cParcela,nParcelas,1)
	aAreaSX3 := SX3->(GetArea())

	DbSelectArea("SX3")
	DbSetOrder(2)
	If !DbSeek(cChave) .or. !DbSeek(cChave1)
		Help(" ",1,"TMKTIP905") //"A quantidade de parcelas nao esta compativel. Verificar junto ao administrador do sistema relacao entre parametro MV_NUMPARC e dicionario de dados"
		Return(lRet)
	EndIf

	Restarea(aAreaSX3)

EndIf

aTipo9 := {}  //Array com os valores das parcelas

For nLinha := 1 TO nLenAux

	//????????????????
	//?e a linha estiver habilitada?
	//????????????????
	If !aCols[nLinha][Len(aHeader)+1]
		//?????????????
		//?alida a Data informada ?
		//?????????????
		If Empty(aCols[nLinha][2]) .OR. (aCols[nLinha][2] < dDataBase)
			Help(" ",1,"TMKTIP903" ) //"A data esta incorreta"
			Return(lRet)
		Endif

		//????????????????
		//?alida Data da ultima parcela ?
		//????????????????
        If nLinha > 1
		    dData := aCols[nUltLinha][2]
		Endif

		If (aCols[nLinha][2] < dData)
			Help(" ",1,"TMKTIP904" ) //"As datas das parcelas precisam ser crescentes","Aten?o")
			Return(lRet)
		Endif

		If Empty(aCols[nLinha][1])
			MsgStop('Nao foi informado o valor da parcela')//"N? foi informado o valor da parcela."
			Return(lRet)
		Endif

		nValParc := 0
		If lValor
			nValParc := aCols[nLinha][1]
		Else
			nValParc := A410Arred((nTotal * aCols[nLinha][1]) / 100,"UB_VRUNIT")
		Endif

		//??????????????????????????????
		//?uando a parcela e informada em % esse valor e convertido ?
		//?ara VALOR (R$) para que entre nas Parcelas da condicao   ?
		//?e pagamento                                              ?
		//??????????????????????????????
		AADD(aTipo9,{	aCols[nLinha][2],;		// 1 - Data
						nValParc,;				// 2 - Valor
						cForma,;				// 3 - Forma
						SPACE(80),;				// 4 - Complemento
						aCols[nLinha][1],;		// 5 - % ou R$
						space(01)})				// 6 - ID Cartao (visualiz. sintetizada)

		//???????????????
		//?e os valores forem em VALOR?
		//???????????????
		If !lValor
			nValTotal += aCols[nLinha][1]
		Else
			nValTotal += A410Arred(aCols[nLinha][1],"UB_VRUNIT")
		Endif

		//????????????????????????
		//?tualiza a vari?el com a ?tima linha v?ida.?
		//????????????????????????
		nUltLinha := nLinha
	Endif

Next nLinha

//??????????????????????????????
//?oma novamente o total das parcelas e joga a diferenca na ?
//?ltima parcela.                                           ?
//??????????????????????????????
nValParc:= 0
nLenAux	:= Len(aTipo9)
For nLinha := 1 TO nLenAux
	aTipo9[nLinha][2] := NoRound(aTipo9[nLinha][2], nDecE1Vlr )
	nValParc += aTipo9[nLinha][2]
Next nLinha

//??????????????
//?e o Acols esta em VALOR.?
//??????????????
nResto := 0
nResto := nTotal - nValParc
If (nResto <> 0)
	nValParc += nResto
	If Len(aTipo9) > 1
		aTipo9[Len(aTipo9)][2]+= nResto
	Endif
Endif

If NoRound(nTotal,2) <> NoRound(nValParc,2)
	Help(" ",1,"TK010VALOK" ) //"O total das parcelas nao est?correto"
	lRet := .F.
Endif

//???????????????????????????????
//?e condicao de pagamento calcular em Percentual, verifico  ?
//?e os percentuais informados somam 100%, caso seja em valor?
//?erifico se a soma das parcelas batem com o total.         ?
//???????????????????????????????
If !lValor
	If nValTotal <> 100
		Help( " ", 1, "TK010VALOK" )
		Return(lRet)
	Endif
//?????????????????????????????
//?e a somatoria das parcelas for <> que o valor total do ?
//?tendimento.                                            ?
//?????????????????????????????
ElseIf nValTotal <> nTotal
	Help( " ", 1, "TK010VALOK" )
	Return(lRet)
Endif

lRet := .T.

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?k273DetSint?utor?Vendas Clientes 	 ?Data ?09/11/05    ??
???????????????????????????????????????
??esc.     ?repara o array aParcelas para ser tratado em uma nova tela,??
??         ?ois na principal sera exibida a Sintetizada.  		      ??
???????????????????????????????????????
??so       ?CALL CENTER - TeleVendas                                   ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273DetSint(	aParcelas	,oParcelas	,aItens		,lHabilita,;
						nLiquido	,nEntrada	,oEntrada	,nFinanciado,;
						oFinanciado	,cCodPagto	,lSigaCRD	,oDlgPagto)

Local lContinua	  := .T.							   					  // Laco para o controle da abertura de tela
Local lConfirma   := .F.												  // Indica se o operador confirmou a altera?o das parcelas
Local nPos		  := 0													  // Identifica a posicao da informacao no Array
Local oDlgPgtoSin									 					  // Objeto para tratamento da janela
Local lTefMult	  := SuperGetMV("MV_TEFMULT")	   						  // Parametro do SX6 que indica se o sistema vai o TEF multiplas transacoes
Local oGetFormas 								   						  // Objeto GET para informar nr. de formas de pagto e/ou cartoes (Mult. transacoes)
Local nFormas	:= 0							   						  // Variavel que guarda o nr. de formas de pagto e/ou cartoes (Mult. transacoes)
Local lHomol	:= FindFunction("U_LJHOMTEF") .AND. LjMSSM0(SM0->M0_CGC)  // Indica que esta fazendo homologacao na Software Express p/ nao exibir as parcelas
Local nNrParc	:= 0								  					  // Nr. de parcelas
Local cForma	:= ""								 					  // Forma de pagto (CC,CH,$)
Private oPgtosAna									 				  	  // Copia do Objeto oParcelas que sera aberto em outra tela

If Len(aPgtosSint) > 0
	nNrParc := aPgtosSint[1][2]
	cForma	:= aPgtosSint[1][1]
	//?????????????????????????????????
	//?Nao exibir as parcelas durante a Homologacao na Soft. Express ?
	//?????????????????????????????????
	If nNrParc > 1 .AND. lHomol
		Return nil
	Endif
Endif

While lContinua

	lConfirma := .F.

	//?????????????????????????????????????
	//?Cria interface com o usuario                                          ?
	//?????????????????????????????????????
	DEFINE MSDIALOG oDlgPgtoSin TITLE 'Detalhes da forma de pagamento' FROM 0,0 TO 20,50 OF oDlgPagto //"Detalhes da Forma de Pagamento"

		DEFINE SBUTTON FROM 136,170	TYPE 1 ACTION (lConfirma := .T. , oDlgPgtoSin:End()) ENABLE

		oPgtosAna	:= TCBrowse()	:New( 5, 5, 190, 125,;
									 Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil,,,,,,,,, .T. )

		oPgtosAna:bLDblClick	:= {|| Tk273Detalhe(@aParcelas	,oParcelas	,@aItens	,lHabilita,;
													nLiquido	,@nEntrada	,oEntrada	,@nFinanciado,;
													oFinanciado	,cCodPagto	,lSigaCRD)  }

		oPgtosAna:SetArray( aParcelas )

		nPos 			:= Ascan(aParcelas, { |x| ( AllTrim(x[3]) == AllTrim(aPgtosSint[oPgtosSint:nAt][1]) ) })
		oPgtosAna:nAt 	:= Iif(nPos>0,nPos,oPgtosAna:nAt)
		//???????????????????????????????????????????????????????
		//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
		//???????????????????????????????????????????????????????
		If !lTk271Auto
			oPgtosAna:Refresh()
			oPgtosAna:SetFocus()
		Endif

		ADD COLUMN TO oPgtosAna HEADER 'Data' OEM DATA	{|| DTOC(aParcelas[oPgtosAna:nAt,1]) }							ALIGN LEFT SIZE 40 PIXEL //"Data"
		ADD COLUMN TO oPgtosAna HEADER 'Valor' OEM DATA {|| Transform(aParcelas[oPgtosAna:nAt,2],"@E 999,999,999.99")}	ALIGN LEFT SIZE 55 PIXEL //"Valor"
		ADD COLUMN TO oPgtosAna HEADER 'Forma' OEM DATA {|| aParcelas[oPgtosAna:nAt,3] } 								ALIGN LEFT SIZE 40 PIXEL //"Forma"

		//?????????????????????????????????????????????
		//?So inserir a coluna ID Cartao quando o cliente trabalhar com multiplas transacoes TEF ?
		//?????????????????????????????????????????????
		If 	lUsaTef 	.AND.;
			lTefMult 	.AND.;
			lVisuSint
			// ID Cartao (6)
			ADD COLUMN TO oPgtosAna HEADER 'ID Cartao' OEM DATA { || aParcelas[oPgtosAna:nAt,6] } 	ALIGN LEFT  SIZE 20 PIXEL //"ID Cartao"
		Endif

		If 	lUsaTef .AND. lTefMult .AND.;
			lVisuSint .AND. nNrParc == 1 .AND. cForma == "CC"
			//????????????????????????????
			//?Get de Nr. de cartoes p/ pagto com multiplos cartoes ?
			//????????????????????????????
			@ 136,10 SAY 'N.Cartao' OF oDlgPgtoSin PIXEL	//"Nr. cart?s: "
			@ 136,60 GET oGetFormas VAR nFormas Picture "@99" SIZE 30,8 PIXEL OF oDlgPgtoSin VALID Tk273AtuParc(nFormas,aParcelas,oPgtosAna,nLiquido)
		EndIf

	ACTIVATE MSDIALOG oDlgPgtoSin CENTERED

	If lConfirma
		oParcelas:SetArray(aParcelas)
		//???????????????????????????????????????????????????????
		//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
		//???????????????????????????????????????????????????????
		If !lTk271Auto
			oParcelas:Refresh()
		Endif

		aPgtosSint := Tk273MontPgt(aParcelas)
		oPgtosSint:SetArray( aPgtosSint )
		//???????????????????????????????????????????????????????
		//?odo refresh de objeto deve considerar se existe ENTRADA AUTOMATICA  ou NAO - no SIGATMK o flag e LTK271AUTO?
		//???????????????????????????????????????????????????????
		If !lTk271Auto
			oPgtosSint:Refresh()
    	Endif

		lContinua := .F.
	Endif
End

Return(Nil)

/*
???????????????????????????????????????
???????????????????????????????????????
? ??????????????????????????????????????
??rograma  ?k273AtuPa?utor  ?endas Clientes      ?Data ? 24/04/06   ??
???????????????????????????????????????
??esc.     ?Atualiza o array de parcelas conforme nr. de cartoes infor- ??
??         ?mados (usada somente em Multiplas Transacoes TEF)           ??
???????????????????????????????????????
??arametros?ExpN1: Nr. de cartoes/formas                                ??
??         ?ExpA2: Array de Parcelas                                    ??
??         ?ExpO3: Objeto com as parcelas calculadas                    ??
??         ?ExpN4: Valor liquido da venda                               ??
???????????????????????????????????????
??so       ?TeleVendas                                                  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273AtuParc(nFormas, aParcelas, oPgtosAna, nLiquido)

Local lRet 		:= .T.		//Indica o retorno da funcao
Local nValTotal := 0		//Valor total da venda
Local nValParc  := 0		//Valor das parcelas
Local nI 		:= 1    	//Variav. usada em lacos For...Next
Local nVlrTotParc:=0		//Totalizador das parcelas

If nFormas <= 0
	MsgStop('O valor dev ser maior que zero','Atencao') //"O valor deve ser maior que zero!"
	lRet := .F.
Endif

If lRet
	//Total da venda
	nValTotal := nLiquido
	aParcelas := {}

	//Valor de cada parcela
	nValParc :=  nValTotal / nFormas

	//Gera as novas parcelas
	For nI := 1 To nFormas
		aAdd(aParcelas, {	dDataBase	, A410Arred(nValParc,"UB_VRUNIT")	, "CC"	, ""	,;
							0			, StrZero(nI,1) 					})
	Next nI

    //Acerta eventuais diferencas por arredondamento
	aEval( aParcelas, { |x| nVlrTotParc += x[2] } )
	If nValTotal <> nVlrTotParc .AND. Len(aParcelas) >= 1
		aParcelas[1][2] += (nValTotal - nVlrTotParc)
	Endif

    oPgtosAna:SetArray(aParcelas)
	If !lTk271Auto
		oPgtosAna:Refresh()
	EndIf

Endif

Return lRet

/*/
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o    ?k273MontPgt?Autor?Vendas Clientes       ?Data ?9/11/05 ??
???????????????????????????????????????
??escri??o ?Prepara a array sintetizada para exibi?o                  ??
???????????????????????????????????????
??so       ?CALL CENTER - TeleVendas                                   ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
/*/
Static Function Tk273MontPgt(aParc)

Local nFor 	 		:= 0															// Usada em lacos For...Next
Local cCond  		:= ""															// Forma Pagto (CC,CH)
Local nValor 		:= 0    														// Valor da parcela
Local nParc	 		:= 0   															// Nr. de parcelas
Local cFormaId 		:= IIf(lVisuSint,Space(TamSX3("L4_FORMAID")[1]),Space(01))		// Id do cartao
Local nPos	 		:= 0															// Posicao dentro do array
Local aParcSint		:= {}															// Array construido com as parcelas sinteticas
Local aSequencia	:= {}															// Array auxiliar do aParc
Local cSimbMoeda	:= SuperGetMv("MV_SIMB"+Ltrim(Str(nMoedaCor)))						// Simbolo da moeda

DEFAULT aParc	  	:= {}	//Array com as parcelas a sintetizar

// Verifica se a aPgtos ou a aDados esta zerada
If Len(aParc) == 1 .AND. aParc[1][2] == 0
	aParcSint := { {Space(02)	,;
					0			,;
					TransForm(0,PesqPict("SL4","L4_VALOR",,nMoedaCor)),;
					Space(TamSX3("L4_FORMAID")[1]),;
					Ctod(Space(8)),;
					{}}}

//Efetua o tratamento para a sintetizacao das informacoes
ElseIf Len(aParc) > 0
	aParcSint := {}						//Limpa o array para soma dos valores sintetizados

	//??????????????????????????????
	//?era array sintetico de acordo com a quantidade de cartoes?
	//??????????????????????????????
	For nFor:= 1 To Len(aParc)

		// Forma Pagto (CC,CH,CD etc)
		cCond  		:= AllTrim(aParc[nFor][3])

		// ID Cartao
		cFormaId 	:= aParc[nFor][6]
		nPos		:= Ascan(aParcSint, { |x| ( AllTrim(x[1]) == cCond .AND. AllTrim(x[4]) == AllTrim(cFormaId) ) })
		If nPos > 0
			aParcSint[nPos][2] := aParcSint[nPos][2] + 1				//Parcela
			aParcSint[nPos][3] := aParcSint[nPos][3] + aParc[nFor][2]	//Valor
		Else
			nParc	:= 1
			nValor	:= aParc[nFor][2]
			Aadd( aParcSint , {	cCond			, nParc	, nValor	, cFormaId	,;
								aParc[nFor][1]	, {}  	})
		Endif

    	Aadd( aSequencia , {nFor , cCond , nValor, cFormaId} )
	Next nFor

	// Atualizando a sequencia para a array aParc
	For nFor := 1 To Len(aParc)

		nPos := Ascan(aSequencia,{|x| x[1] == nFor})
		If nPos > 0
			aParc[nFor][6] := aSequencia[nPos][4]
		Endif

	Next nFor

	//????????????????
	//?ormata na Picture do L4_VALOR?
	//????????????????
	For nFor := 1 to Len(aParcSint)
		aParcSint[nFor][3] := TransForm(aParcSint[nFor][3],PesqPict("SL4","L4_VALOR",,nMoedaCor))
	Next nFor
Endif

aSort( aParcSint,,, {|x,y| Dtos(x[5])+x[1]+x[4] < Dtos(y[5])+y[1]+y[4] } ) //Data + Cond + Seq.

//????????????????????
//?A Forma $ sempre sera a primeira!!!  ?
//????????????????????
If (nPos := Ascan(aParcSint, {|x| x[1] == cSimbMoeda})) > 1
	aAdd(aParcSint,{})
	aIns(aParcSint,1)
	nPos++
	aParcSint[1] := aParcSint[nPos]
	aDel(aParcSint, nPos)
	aSize(aParcSint,Len(aParcSint)-1)
Endif

Return(aParcSint)

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?K273WhenID  ?utor ?Vendas Clientes  ?Data ? 10/11/05   ??
???????????????????????????????????????
??esc.     ?Verifica se e necessaria a digitacao do digito de controle ??
??         ?de cartoes                                                 ??
???????????????????????????????????????
??so       ?CALL CENTER - Televendas                                   ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function TK273WhenID(nLinha,cForma,cFormaID,aItens)

Local lRet 		:= .F.	// Variavel de retorno da funcao
Local nPos 		:= 0	// Posicao localizada no array

nPos := Ascan(aItens,{|x| AllTrim(Upper(x[2]))==AllTrim(Upper(cForma))})
If nPos > 0
	If AllTrim(Upper(aItens[nPos][2])) $ _FORMATEF
		lRet := .T.
	Else
		If lVisuSint
			cFormaID := Space(TamSX3("L4_FORMAID")[1])
		Else
			cFormaID :=	Space(01)
		Endif
	Endif
Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?K273ValidID ?utor ?Vendas Clientes  ?Data ? 10/11/05   ??
???????????????????????????????????????
??esc.     ?Valida se o digito informado e correto para o controle de  ??
??         ?multiplos cartoes                                          ??
???????????????????????????????????????
??arametros?ExpC1: Forma a ser localizada                              ??
??         ?ExpC2: ID do cart? para a opera?o TEF                    ??
??         ?ExpA3: Formas selecionadas                                 ??
???????????????????????????????????????
??etorno   ?ExpL1: .T. se o digito ?validado                          ??
??         ?       .F. se o digito n? ?validado                      ??
???????????????????????????????????????
??so       ?CALL CENTER - Televendas                                   ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function TK273ValidID(cForma,cFormaID,aItens)

Local lRet 	 := .T.			// Retorno da funcao
Local nPos 	 := 0 			// Posicao localizada no array
Local cCond  := Space(02)	// Forma de pagto TEF

nPos := Ascan(aItens,{|x| AllTrim(Upper(x[2])) == AllTrim(Upper(cForma))})	// Posicao localizada no array
If nPos > 0
	cCond := AllTrim( Upper(aItens[nPos][2]) )
Endif

If cCond $ _FORMATEF
	If Empty(cFormaId)
		MsgAlert('Informe o ID do cartao para a operacao TEF','Atencao') //"Informe o ID do Cartao para a operacao TEF.","Atencao"
		lRet := .F.
	Endif
Endif

Return(lRet)

/*
???????????????????????????????????????
???????????????????????????????????????
? ??????????????????????????????????????
??rograma  ?k273ReFil?utor  ?endas Clientes      ?Data ? 25/04/06   ??
???????????????????????????????????????
??esc.     ?Altera os valores das parcelas para que nao haja inconsis-  ??
??         ?tencia nas mesmas.                                          ??
???????????????????????????????????????
??arametros?ExpN1: Parcela Alterada                                     ??
??         ?ExpN2: Total das parcelas                                   ??
??         ?ExpA3: Array de parcelas                                    ??
???????????????????????????????????????
??so       ?TeleVendas                                                  ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273ReFill( nParcAlt, nTotParc, aParcelas )

Local nI		:= 0								//Variavel de apoio
Local nTotTemp 	:= 0								//Total das parcelas menos o valor da parcela alterada e das anteriores
Local nVlrTemp	:= 0								//Valor das parcelas que nao foram alteradas
Local nNumParc	:= Len( aParcelas ) - nParcAlt		//Numero de parcelas que serao alteradas (Somente a partir da parcela atual)

If nParcAlt <> Len( aParcelas ) .OR. Len( aParcelas ) == 1
	nTotTemp := nTotParc
	For nI := 1 To nParcAlt
		nTotTemp -= aParcelas[nI][2]					//Soma o valor das parcelas que nao sofrerao alteracao
	Next nI

	nVlrTemp	:= nTotTemp / nNumParc					//Calcula o novo valor das parcelas

	For nI := nParcAlt+1 To Len( aParcelas )
		aParcelas[nI][2] 	:= A410Arred( nVlrTemp, "UB_VRUNIT" )
		nTotTemp 			-= A410Arred( nVlrTemp, "UB_VRUNIT" )
	Next nI
Endif
Return

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?K273RecCpg  ?utor  ?endas Clientes  ?Data ? 27/07/07   ??
???????????????????????????????????????
??esc.     ?ecalcula o valor dos juros sobre o total de acordo com a   ??
??         ?ondicao de pagamento atual (M->UA_CONDPG).                 ??
???????????????????????????????????????
??arametros?cCond - Codigo da Condicao de Pagamento utilizada.         ??
??         ?        Default = M->UA_CONDPG (campo da Enchoice)         ??
???????????????????????????????????????
??etorno   ?nVlJur - Total de juros calculado                          ??
???????????????????????????????????????
??so       ?CALL CENTER                                                ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273RecCpg( cCond, lValidPgto, nLinha, nVlrAItem )

Local aArea		:= GetArea()					// Armazena tabela, indice e recno atual
Local aAreaSE4	:= SE4->(GetArea())			// Armazena indice e recno atual da SE4
Local nTxJuros	:= 0							// Taxa de juros para a condicao de pagamento atual
Local nVlJur	:= 0							// Valor dos juros sobre o total da venda
Local nJurUnit	:= 0							// Valor dos juros sobre o preco unitario
Local nLiquido 	:= 0							// Valor liquido do atendimento
Local i			:= 0							// Contador de laco
Local lTKVDACR	:= Iif(SuperGetMV("MV_TMKLOJ",,.F. )== "S" .And. GetNewPar("MV_TKVDACR",.F.),.T.,.F.)	//Se possuir integra?o com o SIGALOJA, faz o c?culo do acrescimo sobre o total menos o desconto.
Local cAgregaValor
Local nPosTES	:= GDFieldPos("UB_TES")
Local nAcresFin := 0


Default cCond	  	:= M->UA_CONDPG				// Condicao de pagamento digitada na Enchoice
Default lValidPgto	:= .F.
Default nLinha		:= 0
Default nVlrAItem	:= 0

DbSelectArea("SE4")
DbSetOrder(1)

If DbSeek(xFilial("SE4")+cCond)

	nTxJuros := SE4->E4_ACRSFIN
	nLiquido := aValores[BASEDUP] - aValores[ACRESCIMO]

	If nLiquido > 0 .Or. nTxJuros > 0

		//????????????????????????????????????????
		//?alculo dos juros para atualizar o ACRESCIMO e o valor TOTAL do atendimento. ?
		//?ara compatibilizar com o Faturamento, calcula o acrescimo a partir do preco ?
		//?nitario, arredonda e depois multiplica pela quantidade vendida, arredondando?
		//?ovamente.                                                                   ?
		//????????????????????????????????????????
		For i := 1 to Len( aCols )

			cAgregaValor := ''
			DbSelectArea("SF4")
			DbSetOrder(1)
	   		If DbSeek(xFilial("SF4")+ aCols[i][nPosTES])
				cAgregaValor := SF4->F4_AGREG
			Endif


			If !GDDeleted(i) .And. cAgregaValor <> 'N'	// Se a linha nao estiver deletada
				nJurUnit  := A410Arred(GDFieldGet("UB_VRUNIT",i) * SE4->E4_ACRSFIN / 100,"UB_VRUNIT")
				nAcresFin := A410Arred(GDFieldGet("UB_QUANT" ,i) * nJurUnit,"UB_VLRITEM")
				nVlJur	  += nAcresFin

				If nLinha == i
					nVlrAItem := nAcresFin
				Endif
			EndIf

		Next i

		//??????????????????????????????????????
		//?uando possuir integra?o com o SIGALOJA, calcula o acrescimo sobre o 	?
		//?otal menos o desconto. ((TOTAL - DESCONTO) + ACRESCIMO)					?
		//? regra utilizada por padr? no Faturamento e no Televendas ?a seguinte:?
		//?(TOTAL + ACRESCIMO) - DESCONTO)                                        	?
		//??????????????????????????????????????
		If lTKVDACR .And. M->UA_OPER == "2" .And. !lValidPgto 		//Or?mento
			nVlJur := (A410Arred(nVlJur,"UB_VLRITEM") - A410Arred(aValores[DESCONTO]*SE4->E4_ACRSFIN/100, "UB_VRUNIT"))
		Else
			nVlJur := A410Arred(nVlJur,"UB_VLRITEM")
		EndIf

		Tk273CalcAcre(nTxJuros,nVlJur)

	EndIf

EndIf

RestArea(aAreaSE4)
RestArea(aArea)

Return nVlJur

/*
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
??un??o	 ?k273Trans     ?Autor ?endas Clientes   ?Data ?9/08/07  ??
???????????????????????????????????????
??escri??o ?ncapsulamento do ponto de entrada TMKTRANS:                ??
??         ?tualiza dados referentes a transporte e endereco de entrega??
???????????????????????????????????????
??arametros?ExpC1 = Codigo da transportadora                           ??
??         ?ExpC2 = Nome da transportadora                             ??
??         ?ExpC3 = Codigo da condicao de pagament                     ??
??         ?ExpC4 = Descricao da condicao                              ??
??         ?ExpC5 = Endereco de entrega                                ??
??         ?ExpC6 = Bairro de entrega                                  ??
??         ?ExpC7 = Cidade de entrega                                  ??
??         ?ExpC8 = CEP de entrega                                     ??
??         ?ExpC9 = Estado de entrega                                  ??
???????????????????????????????????????
??so       ?TeleVendas                                                 ??
???????????????????????????????????????
??         ?       ?     ?                                           ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function Tk273Trans(	cCodTransp	, cTransp	, cCodPagto	, cDescPagto,;
							cEnt		, cBairroE	, cCidadeE	, cCepE		,;
							cUfE		)

Local nCont		:= 0													// Contador auxiliar para loop
Local aArea		:= GetArea()											// Armazena tabela, indice e recno atual
Local lTmkTrans := FindFunction("U_TMKTRANS")							// P.E. para permitir escolha da transportadora e dados de entrega
Local aRetTrans := {cCodTransp	, cCodPagto	, cEnt		, cBairroE	,;	// Retorno no P.E. TMKTRANS com a sele?o da transportadora de acordo com as regras de neg?io espec?icas
					cCidadeE	, cCepE		, cUfE		}

//?????????????????????????????
//?onto de Entrada para permitir ao usuario escolher a   ?
//?ransportadora e dados de entrega de acordo com alguma ?
//?egra de negocio especifica.                           ?
//?????????????????????????????
If lTmkTrans

	aRetTrans := U_TMKTRANS(aRetTrans)

	If Len(aRetTrans) > 0
		cCodTransp := aRetTrans[1]
		If Len(aRetTrans) >= 2
			cCodPagto := aRetTrans[2]
		Endif
	Endif

	//???????????????????????????????????
	//?erifica se o retorno do array aRetTrans e valido e contem as 	   ?
	//?nformacoes para preenchimento dos dados de entrega. 			   ?
	//???????????????????????????????????
	If Len(aRetTrans) >= 3
		For nCont:=3 to Len(aRetTrans)
			If ValType(aRetTrans[nCont]) <> "C"
				Loop
			Else
				Do Case
					Case nCont == 3 .AND. !Empty(aRetTrans[nCont])
						cEnt:=aRetTrans[nCont]
					Case nCont == 4 .AND. !Empty(aRetTrans[nCont])
						cBairroE:=aRetTrans[nCont]
					Case nCont == 5 .AND. !Empty(aRetTrans[nCont])
						cCidadeE:=aRetTrans[nCont]
					Case nCont == 6 .AND. !Empty(aRetTrans[nCont])
						cCepE:=aRetTrans[nCont]
					Case nCont == 7 .AND. !Empty(aRetTrans[nCont])
						cUfE:=aRetTrans[nCont]
				Endcase
			Endif
		Next nCont
	Endif
EndIf

DbSelectArea("SE4")
DbSetOrder(1)
If DbSeek(xFilial("SE4")+ cCodPagto )
	cDescPagto:= SE4->E4_DESCRI
Endif

DbSelectArea("SA4")
DbSetOrder(1)
If DbSeek(xFilial("SA4") + cCodTransp)
	cTransp		:= SA4->A4_COD+"-"+SA4->A4_NOME
Endif

RestArea(aArea)

Return Nil


/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?K273VCond?utor  ?endas Cliente      ?Data ? 12/12/07   ??
???????????????????????????????????????
??esc.     ?ecalcula os juros da condicao de pagamento e atualiza o    ??
??         ?odape com os totais.                                       ??
???????????????????????????????????????
??so       ?ALL CENTER - Televendas                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function TK273VCond(lOperacao)

DEFAULT lOperacao := .F.

If !lOperacao
	Tk273RecCpg( &(ReadVar()),.T. )
Else
	Tk273RecCpg( UA_CONDPG,.T. )
EndIf

Return .T.

/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?K273ValOper?utor  ?endas Cliente      ?Data ? 13/03/12 ??
???????????????????????????????????????
??esc.     ?Fun?o utilizada no X3_VALID do campo UA_OPER.			  ??
???????????????????????????????????????
??so       ?ALL CENTER - Televendas                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function TK273VdJur()

Local lTKVDACR	:= Iif(SuperGetMV("MV_TMKLOJ",,.F. )== "S" .And. GetNewPar("MV_TKVDACR",.F.),.T.,.F.)	//Se possuir integra?o com o SIGALOJA, faz o c?culo do acrescimo sobre o total menos o desconto.

If lTKVDACR
	Tk273VCond(.T.)
	Tk273Recalc(,,.T.)
EndIf

Return .T.


/*
???????????????????????????????????????
???????????????????????????????????????
? ?????????????????????????????????????
??rograma  ?K273ValTrans?utor ?endas Cliente      ?Data ? 25/06/12 ??
???????????????????????????????????????
??esc.     ?Fun?o utilizada do campo UA_TRANS.	   					  ??
???????????????????????????????????????
??so       ?ALL CENTER - Televendas                                    ??
???????????????????????????????????????
???????????????????????????????????????
???????????????????????????????????????
*/
Static Function TK273ValTrans(cCodTransp,cTransp,oTransp)
Local lRet := .T.
Local cBloq			:= ""										// Vari?el para verificacao de boloqueio da transportadora

If !Empty(cCodTransp)
	DbSelectArea("SA4")
	DbSetOrder(1)
	If DbSeek(xFilial("SA4")+cCodTransp)
		cBloq := FieldGet(FieldPos("A4_MSBLQL"))
		If Empty(cBloq) .OR. cBloq == "2"
			cTransp := SA4->A4_NOME
			//??????????????????????
			//?e nao estiver usando a entrada automatica?
			//??????????????????????
			If !lTk271Auto
				If ValType(oTransp)=="O"
					oTransp:Refresh()
				EndIf
			Endif
			lRet := .T.
		Else
			Help("",1,"REGBLOQ")
			lRet := .F.
		EndIf
	Else
		Help(" ",1,"REGNOIS")
		lRet:= .F.
	EndIf
EndIf

Return(lRet)

//---------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TK273LdSx3

Retorna as informa?es contidas no dicion?io de dados para ser utilizado nos MSGETs

@sample	TK273LdSx3()

@param		Nenhum

@return	ExpA Array contendo o nome e a propriedade de cada campo da tabela SUA

@author Eduardo Yamamoto
@since		17/06/2014
@version	11.8
/*/
//---------------------------------------------------------------------------------------------------------------
Static Function TK273LdSx3()

Local aArea := GetArea()
Local aRet  := {}

DbSelectArea("SX3")
dbSetOrder(1)
MsSeek("SUA")

While ( !Eof() .And. SX3->X3_ARQUIVO == "SUA" )

	AADD(aRet, {AllTrim(SX3->X3_CAMPO), IIF(SX3->X3_VISUAL == 'V', .F., .T.) })
	dbSkip()

EndDo

RestArea(aArea)

Return aRet

Static Function RecDesc6(pValor,nCodPagto)
//Local a 		:= 1
Local nCompVal 	:= 0
Local cPedComp 	:= M->UA_ZPEDCOM
Local cFilComp  := M->UA_ZFILCOM
Local _lDes6F	:= SuperGetMV("D6FRETE",.F.,.F.)

// validação de condição de pagamento por Número de Famílias de produtos OU Estado do cliente
If !(U_MTXXPG(.F.))
	Return(.F.)
EndIf

If _lDes6F .and. cFilAnt$"0101/0201" .and. M->UA_TPFRETE=="F"
	Return()
EndIf

aAreaSUA		:= SUA->(GetArea())

SUA->(DBSetOrder(1))
SUA->(DBGoTop())

If !Empty(cPedComp)

	If SUA->(DbSeek(cFilComp+cPedComp))
		nCompVal := SUA->UA_VLRLIQ
	EndIf

EndIf
RestArea(aAreaSUA)

If nCodPagto <> M->UA_CONDPG 
	If (pValor+nCompVal) <= 5000 .or. (cFilAnt$"0101/0201") //Se for ferragens e condicao diferente de avista zera desconto 6
		M->UA_ZDESCES := 0

		U_CALCDESC("UB_VRUNIT")
		EVal(bGDRefresh)

		if (cFilAnt$"0101/0201")
			MsgInfo("Condição de pagamento alterada, Desconto 6 foi retirado!")
		endif

		/*
		SaveInter()
		U_MTX13P07(.T.)
		RestInter()
		*/
	EndIf
EndIf

Return()

// Gustavo - Gruppe Tecnologia 06/09/21
// Função para filtrar condições de pagamento específicas Belluno para clientes Pessoa Física
// usada na consulta padrão SE403, campo UA_CONDPG
User Function MTXVLDPG()
Local lRet := .T.
Local cPessoa := Posicione("SA1",1,xFilial("SA1")+M->UA_CLIENTE+M->UA_LOJA,"A1_PESSOA")

If cPessoa == "F"
	// Se não for a Vista, efetua a validação
	IF SE4->E4_CODIGO != "001"
		If SE4->E4_ZBELLNO != "1"
			lRet := .F.
		EndIf
	ENDIF
EndIf

Return(lRet)

// Gustavo - Gruppe Tecnologia 06/09/21
// Função para filtrar condições de pagamento específicas Belluno para clientes Pessoa Física
// usada na consulta padrão SE4, campo UA_CONDPG
User Function MTXXPG(lPosic)
Local lRet := .T.
Local cEst := ""

If IsInCallStack("TMKA271")
	lRet := .F.
	cEst := Posicione("SA1",1,xFilial("SA1")+M->UA_CLIENTE+M->UA_LOJA,"A1_EST")

	If lPosic
		DbSelectArea("SE4")
		DbSetOrder(1)
		DbSeek(xFilial("SE4")+M->UA_CONDPG)
	EndIf
	
	If !Empty(SE4->E4_ZEST)
		If SE4->E4_ZEST == cEst
			lRet := .T.
		EndIf
	Else
		If SE4->E4_ZFAMMIN <= M->UA_ZNUMFAM
			lRet := .T.
		EndIf
	EndIf

EndIf

Return(lRet)

//Atualiza o valor de desconto do SAC caso não confirme a forma de pagamento.
Static Function sfAtuDesc()
Local _cQuery   := ""
Local _nValSac  := 0
Local _aRetSQL  := {}
Local nX

If M->UA_ZCRESAC == "S"

	_cQuery := " SELECT E1_FILIAL,E1_PREFIXO,E1_NUM,E1_PARCELA,E1_TIPO,E1_SALDO"    + CRLF
	_cQuery += " FROM  " + RetSqlTab("SE1")                                                                    + CRLF
	_cQuery += " INNER  JOIN  " + RetSqlName("SA1") + " SA1 ON "+RetSqlCond("SA1")+" AND A1_COD = E1_CLIENTE AND A1_LOJA = E1_LOJA   " + CRLF
	_cQuery += " INNER  JOIN  " + RetSqlName("SZ0") + " SZ0 ON "+RetSqlCond("SZ0")+" AND E1_PREFIXO = Z0_PREFIXO AND E1_NUM = Z0_NUM AND E1_PARCELA = Z0_PARCELA AND E1_TIPO = Z0_TIPO  " + CRLF
	_cQuery += " WHERE  " + RetSqlCond('SE1')                                                                  + CRLF
	_cQuery += " AND E1_SALDO  > 0   " + CRLF
	_cQuery += " AND E1_TIPO      = '" + PadR( "CNC"  ,TamSX3("E2_TIPO")[1]) + "'" + CRLF
    _cQuery += " AND E1_ZSAC      = '" + PadR( "1"  ,TamSX3("E1_ZSAC")[1]) + "'" + CRLF
	_cQuery += " AND A1_COD       = '" + M->UA_CLIENTE   + "'" + CRLF
	_cQuery += " AND A1_LOJA      = '" + M->UA_LOJA      + "'" + CRLF
    _cQuery += " AND Z0_ORCAMEN   = '" + M->UA_NUM       + "'" + CRLF
    //_cQuery += " AND Z0_STATUS    = 'O' " + CRLF

	memowrit("C:\query\TMKVPA_sfAtuDesc.txt",_cQuery)

	_aRetSQL := U_SqlToVet(_cQuery)

	If Len(_aRetSQL) > 0

		For nX := 1 To Len(_aRetSQL)

            _nValSac += _aRetSQL[nX][06]

			SZ0->(dbSetOrder(1))//Z0_FILIAL+Z0_PREFIXO+Z0_NUM+Z0_PARCELA+Z0_TIPO
			If SZ0->(dbSeek( _aRetSQL[nX][01] + _aRetSQL[nX][02] + _aRetSQL[nX][03] + _aRetSQL[nX][04] + _aRetSQL[nX][05]))

				RecLock("SZ0", .F.)
                SZ0->( DbDelete() )
				SZ0->(MsUnlock())

			EndIf

		Next _nX

	EndIf

    AVALORES[02] := AVALORES[02] - _nValSac
    Tk273Desconto("NF_DESCONTO",@aValores[02])
    Tk273FRefresh()// Efetua o Refresh do Folder
    oGetTlv:oBrowse:Refresh()//Efetua o Refresh da GetDados
    Tk273Refresh()// Efetua o Refresh da NF

    M->UA_ZCRESAC := " "

EndIf

Return()

Static Function VldDesc(MVPGTO)
Local lRet		:= .T.
Local lCont		:= .F.
Local cUf		:= ""
Local cCondAV	:= SuperGetMv("ZDESC6VIST", .F., "")

If cFilAnt$"0101/0201" .And. M->UA_TPFRETE=="F"
	cUf := POSICIONE("SA1",1,xFilial("SA1")+M->UA_CLIENTE+M->UA_LOJA,"A1_EST")
	If cUf == "SC"
		lCont := .T.
	EndIf
EndIf

If !lCont
	If M->UA_ZDESCES > 0 .And. !(MVPGTO $ cCondAV)
		MsgStop("Você está inserindo uma condição de pagamento não pertencente a política comercial de desconto especial. Somente as seguintes condições são aceitas: " + AllTrim(cCondAV))
		lRet := .F.
	EndIf
EndIf

Return(lRet)
